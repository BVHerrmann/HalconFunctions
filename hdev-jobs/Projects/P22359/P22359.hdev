<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="23.05.0.0">
<procedure name="main">
<interface/>
<body>
<l>global tuple GlobalFileNameInternCamPar</l>
<l>global tuple GlobalFileNameExternCamPar</l>
<c></c>
<l>GlobalFileNameInternCamPar := 'InternalCameraParameter.dat'</l>
<l>GlobalFileNameExternCamPar := 'ExternalCameraParameter.dat'</l>
<c></c>
<l>FirstStartCamerCalibration := 0</l>
<l>CameraCalibrationInternOn := 0</l>
<l>CameraCalibrationExternOn := 0</l>
<l>UseFrameGrabber := 0</l>
<l>SaveFile := 0    </l>
<l>ImageCounter := 0</l>
<l>Width := 4096</l>
<l>Height := 1024</l>
<l>PixelSizeInMPerPixel := 0.000354</l>
<l>LineSpeedInMMPerSec := 25.0</l>
<l>LeftSide := 1  </l>
<l>CheckGlasEdge:=0</l>
<l>CheckDataMatrixCode:=1</l>
<l>CameraName := '00305348ed3f_Basler_raL409624gm'</l>
<l>CameraName := '00305348f5cb_Basler_raL819212gm'</l>
<c></c>
<l>* MarkDistInMeter:=0.02</l>
<l>* DiameterRatio :=0.5</l>
<l>* YNum:=9</l>
<l>* XNum:=34</l>
<l>* DiameterInMeter := MarkDistInMeter*DiameterRatio  </l>
<l>*   MarkPosRow:=(YNum-1)/2</l>
<l>*   MarkPosCol:=(XNum-1)/2</l>
<l>*   create_caltab(YNum,XNum,DiameterInMeter,MarkPosRow,MarkPosCol,'dark_on_light','CalibrationPlate.cpd','PosScriptHexTab.ps')</l>
<l>* gen_caltab(XNum,YNum,MarkDistInMeter,DiameterRatio,'CalibrationPlate.descr','PosScriptab9_34.ps')</l>
<l>* create_caltab(29,19,0.005,14,9,'dark_on_light','CalibrationPlate.cpd','PosScriptHexTab.ps')</l>
<c></c>
<l>if(UseFrameGrabber==1)</l>
<l>    try</l>
<l>        open_framegrabber ('GigEVision2', 0, 0, 0, 0, 0, 0, 'default', -1, 'default', -1, 'false', 'default', CameraName, 0, -1, AcqHandle)</l>
<l>        AqusitionFrameRateLineScanCamera:=LineSpeedInMMPerSec/(PixelSizeInMPerPixel*1000)</l>
<l>        set_framegrabber_param (AcqHandle, 'TriggerMode', 'Off')</l>
<l>        set_framegrabber_param (AcqHandle, 'ExposureTimeAbs', 500)</l>
<l>        set_framegrabber_param (AcqHandle, 'Height',1200)</l>
<l>        *set_framegrabber_param (AcqHandle, 'AcquisitionLineRateAbs',AqusitionFrameRateLineScanCamera)</l>
<l>        grab_image (InputImage, AcqHandle)</l>
<l>        get_image_size (InputImage, Width, Height)</l>
<l>   catch (Exception)</l>
<l>         dev_get_exception_data(Exception, 'error_message',ErrorMsg)</l>
<l>         dev_disp_text ('Framegrabber Error: ' + ErrorMsg, 'image',20,20,'red', [], [])</l>
<l>         set_framegrabber_param (AcqHandle, 'do_abort_grab', 0)</l>
<l>         close_framegrabber (AcqHandle)</l>
<l>         return()</l>
<l>    endtry</l>
<l>else</l>
<l>    *list_image_files ('RecordingInternCalibrationData', 'bmp', [], ImageFiles)</l>
<l>    list_image_files ('Images/DataMatrixCode/io', 'default', [], ImageFiles)</l>
<l>    *list_image_files ('Images/GlasEdge', 'default', [], ImageFiles)</l>
<l>    *list_image_files ('', 'default', [], ImageFiles)</l>
<l>    if(|ImageFiles| &gt;0)</l>
<l>        ImageCounter:=0</l>
<l>        read_image (InputImage, ImageFiles[ImageCounter])</l>
<l>        get_image_size (InputImage, Width, Height)</l>
<l>    else</l>
<l>       return() </l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>dev_close_window ()</l>
<l>while(1)</l>
<l>     if(UseFrameGrabber==1)</l>
<l>       grab_image_async(InputImage, AcqHandle,-1)</l>
<l>     else</l>
<l>        if(ImageCounter &gt;= |ImageFiles|)</l>
<l>          ImageCounter:=0  </l>
<l>        endif</l>
<l>           read_image (InputImage, ImageFiles[ImageCounter])</l>
<l>           if(ImageFiles[ImageCounter]=='Images/GlasEdge/LeftEdge.tiff')</l>
<l>             LeftSide := 1  </l>
<l>           else</l>
<l>             LeftSide := 0  </l>
<l>           endif</l>
<l>        ImageCounter:=ImageCounter+1</l>
<l>     endif</l>
<l>     if(SaveFile)</l>
<l>       CurrentImagePath:='Images' + '/Image' + ImageCounter + '.tif'</l>
<l>       write_image (InputImage, 'tiff', 0, CurrentImagePath)</l>
<l>       ImageCounter:=ImageCounter+1</l>
<l>       stop()</l>
<l>     endif</l>
<l>     if(CameraCalibrationInternOn)</l>
<l>         if(FirstStartCamerCalibration == 0)</l>
<l>               init_line_scan_calibration_stripe_position(InputImage,JobPass,MeasureTimeInMs)</l>
<c>               *Kalibrierung für DMC nicht zwingend erforderlich</c>
<l>               *init_line_scan_calibration_DMC (InputImage, JobPass, MeasureTimeInMs, DebugText)</l>
<l>             if(JobPass == 1)</l>
<l>                FirstStartCamerCalibration := 1 </l>
<l>                stop()</l>
<l>             endif</l>
<l>         else</l>
<l>             if(ImageCounter &lt;= |ImageFiles|)</l>
<l>                 evaluate_line_scan_calibration_images (InputImage, JobPass, MarksDiameterScore, OverexposureScore, ContrastScore, HomogeneityScore, FocusScore, NumImageScore, TiltScore, FielOfVieScore, MeanSquareError, CurrentImages, MeasureTimeInMs)</l>
<l>                 if(ImageCounter == |ImageFiles|)</l>
<l>                      save_line_scan_camera_parameter_stripe_position (InputImage, JobPass)</l>
<c>                      *Kalibrierung für DMC nicht zwingend erforderlich</c>
<l>                      *save_line_scan_camera_parameter_DMC(InputImage, JobPass)</l>
<l>                      stop()</l>
<l>                      CameraCalibrationOn := 0</l>
<l>                      break</l>
<l>                 endif</l>
<l>             endif</l>
<l>         endif</l>
<l>     else</l>
<l>         if(CameraCalibrationExternOn)</l>
<l>             CalibrationMatrixXInRobotCoor  := 4</l>
<l>             CalibrationMatrixYInRobotCoor  := 1</l>
<l>             MaxIterationsCameraCalibration := CalibrationMatrixXInRobotCoor*CalibrationMatrixYInRobotCoor</l>
<l>             StartXPos := -60.0</l>
<l>             StartYPos := 0.0</l>
<l>             OffsetX := 20.0</l>
<l>             OffsetY := 20.0</l>
<l>             RobotTransZ := 500</l>
<l>             RobotRotX := 0.0</l>
<l>             RobotRotY := 0.0</l>
<l>             RobotRotZ := 0.0</l>
<l>             k := 1</l>
<l>             CurrentIndex:=0</l>
<l>             for Y := 0 to CalibrationMatrixYInRobotCoor-1 by 1</l>
<l>                for X := 0 to CalibrationMatrixXInRobotCoor-1 by 1</l>
<l>                    RobotTransX:=StartXPos + OffsetX * X</l>
<l>                    RobotTransY:=StartYPos + OffsetY * Y</l>
<c>                    *GenTestCalibImage(InputImage,800*k,Width, Height)</c>
<l>                    k := k + 1</l>
<l>*                   calibrate_scara_extern_paramter_stationary (InputImage, RobotTransX, RobotTransY, RobotTransZ, RobotRotX, RobotRotY, RobotRotZ, CurrentIndex, JobPass)</l>
<l>                    if(JobPass)</l>
<l>                      CurrentIndex:=CurrentIndex+1</l>
<l>                    endif</l>
<l>                    stop()</l>
<l>                endfor</l>
<l>                if(CurrentIndex&gt;=MaxIterationsCameraCalibration)</l>
<l>                  CameraCalibrationExternOn:=0</l>
<l>                endif</l>
<l>             endfor</l>
<l>          else</l>
<l>                 if(CheckGlasEdge==1)</l>
<l>                   RoiLeftOffsetInMM := 60</l>
<l>                   RoiLeftWidthInMM := 300</l>
<l>                   RoiRightOffsetInMM := 60</l>
<l>                   RoiRightWidthInMM := 300</l>
<l>                   EdgeTreshold := 90</l>
<l>                   glas_edge_detection (InputImage, LeftSide, RoiLeftOffsetInMM, RoiLeftWidthInMM, RoiRightOffsetInMM, RoiRightWidthInMM, EdgeTreshold, JobPass, CurrentPosInMM, LastPosInMM, DistanceInMM, EdgeResult, SecondEdgeResult, CameraLeft)</l>
<l>                 endif</l>
<l>                 if(CheckDataMatrixCode==1)</l>
<l>                   RoiOffsetInMM := 220</l>
<l>                   RoiWidthInMM := 60</l>
<l>                   find_data_matrix_line_scan (InputImage, 'Data Matrix ECC 200', RoiOffsetInMM, RoiWidthInMM, JobPass, ResultCode, CodeXPosInMM, Contrast, CellDefects, ContrastSNR, PatternDefects)</l>
<l>                 endif</l>
<l>                 stop()</l>
<l>          endif</l>
<l>     endif</l>
<l>endwhile</l>
<c></c>
<l>if(UseFrameGrabber==1)</l>
<l> set_framegrabber_param (AcqHandle, 'do_abort_grab', 0)</l>
<l> close_framegrabber (AcqHandle)</l>
<l>endif</l>
<l>return()</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="p_disp_text_right_of_center">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Text" base_type="ctrl" dimension="0"/>
<par name="RowFirst" base_type="ctrl" dimension="0"/>
<par name="ColFirst" base_type="ctrl" dimension="0"/>
<par name="RowSecond" base_type="ctrl" dimension="0"/>
<par name="ColSecond" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
<par name="Distance" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Determine factors for the adaptation of the string extents that might be necessary</c>
<c>* because of image zooming.</c>
<l>get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)</l>
<l>FactorRow := 1. * (Row2Part - Row1Part + 1) / HeightWin</l>
<l>FactorColumn := 1. * (Column2Part - Column1Part + 1) / WidthWin</l>
<c></c>
<c>* Determine the extent of the string and its position.</c>
<l>get_string_extents (WindowHandle, Text, Ascent, Descent, Width, Height)</l>
<l>Width := Width * FactorColumn</l>
<l>Height := Height * FactorRow</l>
<l>RowCenter := (RowFirst + RowSecond) / 2.0</l>
<l>ColCenter := (ColFirst + ColSecond) / 2.0</l>
<l>if (sin(Phi) &lt; 0)</l>
<l>    Distance := -Distance</l>
<l>endif</l>
<l>RowPos := RowCenter + Distance * cos(Phi)</l>
<l>ColPos := ColCenter + Distance * sin(Phi)</l>
<l>RowText := RowPos - Height / 2.0</l>
<l>ColText := ColPos</l>
<c></c>
<c>* Set the text position and color and display the text.</c>
<l>set_tposition (WindowHandle, RowText, ColText)</l>
<l>dev_set_color ('black')</l>
<l>write_string (WindowHandle, Text)</l>
<l>return ()</l>
</body>
<docu id="p_disp_text_right_of_center">
<short lang="de_DE">Displays text right of the center of two given points.</short>
<short lang="en_US">Displays text right of the center of two given points.</short>
<parameters>
<parameter id="ColFirst"/>
<parameter id="ColSecond"/>
<parameter id="Distance"/>
<parameter id="Phi"/>
<parameter id="RowFirst"/>
<parameter id="RowSecond"/>
<parameter id="Text"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="p_disp_edge_marker">
<interface>
<ic>
<par name="Rows" base_type="ctrl" dimension="0"/>
<par name="Cols" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
<par name="Length" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="LineWidth" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Determine the number of edges</c>
<l>NumRows := |Rows|</l>
<l>NumCols := |Cols|</l>
<l>Num := min([NumRows,NumCols])</l>
<c></c>
<c>* Loop over the edges</c>
<l>for i := 0 to Num - 1 by 1</l>
<l>    Row := Rows[i]</l>
<l>    Col := Cols[i]</l>
<c></c>
<c>    * Determine start and end point of the edge marker.</c>
<l>    RowStart := Row + Length * cos(Phi)</l>
<l>    RowEnd := Row - Length * cos(Phi)</l>
<l>    ColStart := Col + Length * sin(Phi)</l>
<l>    ColEnd := Col - Length * sin(Phi)</l>
<c></c>
<c>    * Generate a contour that connects the start and end point.</c>
<l>    gen_contour_polygon_xld (Marker, [RowStart,RowEnd], [ColStart,ColEnd])</l>
<c></c>
<c>    * Display the contour with  the specified style.</c>
<l>    dev_set_color (Color)</l>
<l>    dev_set_line_width (LineWidth)</l>
<l>    dev_display (Marker)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="p_disp_edge_marker">
<short lang="de_DE">Displays a marker, which indicates the position of an edge</short>
<short lang="en_US">Displays a marker, which indicates the position of an edge</short>
<parameters>
<parameter id="Color"/>
<parameter id="Cols"/>
<parameter id="Length"/>
<parameter id="LineWidth"/>
<parameter id="Phi"/>
<parameter id="Rows"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="p_disp_dimensions">
<interface>
<ic>
<par name="RowEdgeFirst" base_type="ctrl" dimension="0"/>
<par name="ColumnEdgeFirst" base_type="ctrl" dimension="0"/>
<par name="RowEdgeSecond" base_type="ctrl" dimension="0"/>
<par name="ColumnEdgeSecond" base_type="ctrl" dimension="0"/>
<par name="IntraDistance" base_type="ctrl" dimension="0"/>
<par name="InterDistance" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
<par name="Length" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Display markers for the edges.</c>
<l>p_disp_edge_marker (RowEdgeFirst, ColumnEdgeFirst, Phi, Length, 'white', 2, WindowHandle)</l>
<l>p_disp_edge_marker (RowEdgeSecond, ColumnEdgeSecond, Phi, Length, 'white', 2, WindowHandle)</l>
<c>* Loop over all edge pairs.</c>
<l>Number := |RowEdgeFirst|</l>
<l>for i := 0 to Number - 1 by 1</l>
<c></c>
<c>    * Display the IntraDistance between the edges.</c>
<l>    Text := IntraDistance[i]</l>
<l>p_disp_text_right_of_center (WindowHandle, Text$'.2f', RowEdgeFirst[i], ColumnEdgeFirst[i], RowEdgeSecond[i], ColumnEdgeSecond[i], Phi, 2.0 * Length)</l>
<l>endfor</l>
<c></c>
<c>* Loop to display the distance between the edge pairs.</c>
<l>for i := 0 to Number - 2 by 1</l>
<c></c>
<c>    * Display the InterDistance between the edge pairs.</c>
<l>    Text := InterDistance[i]</l>
<l>p_disp_text_left_of_center (WindowHandle, Text$'.2f', RowEdgeSecond[i], ColumnEdgeSecond[i], RowEdgeFirst[i + 1], ColumnEdgeFirst[i + 1], Phi, 2.0 * Length)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="p_disp_dimensions">
<short lang="de_DE">Displays the dimension of the measured edge pairs.</short>
<short lang="en_US">Displays the dimension of the measured edge pairs.</short>
<parameters>
<parameter id="ColumnEdgeFirst"/>
<parameter id="ColumnEdgeSecond"/>
<parameter id="InterDistance"/>
<parameter id="IntraDistance"/>
<parameter id="Length"/>
<parameter id="Phi"/>
<parameter id="RowEdgeFirst"/>
<parameter id="RowEdgeSecond"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="p_disp_text_left_of_center">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Text" base_type="ctrl" dimension="0"/>
<par name="RowFirst" base_type="ctrl" dimension="0"/>
<par name="ColFirst" base_type="ctrl" dimension="0"/>
<par name="RowSecond" base_type="ctrl" dimension="0"/>
<par name="ColSecond" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
<par name="Distance" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Determine factors for the adaptation of the string extents that might be necessary</c>
<c>* because of image zooming.</c>
<l>get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)</l>
<l>FactorRow := 1. * (Row2Part - Row1Part + 1) / HeightWin</l>
<l>FactorColumn := 1. * (Column2Part - Column1Part + 1) / WidthWin</l>
<c></c>
<c>* Determine the extent of the string and its position.</c>
<l>get_string_extents (WindowHandle, Text, Ascent, Descent, Width, Height)</l>
<l>Width := Width * FactorColumn</l>
<l>Height := Height * FactorRow</l>
<l>RowCenter := (RowFirst + RowSecond) / 2.0</l>
<l>ColCenter := (ColFirst + ColSecond) / 2.0</l>
<l>if (sin(Phi) &lt; 0)</l>
<l>    Distance := -Distance</l>
<l>endif</l>
<l>RowPos := RowCenter - Distance * cos(Phi)</l>
<l>ColPos := ColCenter - Distance * sin(Phi)</l>
<l>RowText := RowPos - Height / 2.0</l>
<l>ColText := ColPos - Width</l>
<c></c>
<c>* Set the text position and color and display the text.</c>
<l>set_tposition (WindowHandle, RowText, ColText)</l>
<l>dev_set_color ('black')</l>
<l>write_string (WindowHandle, Text)</l>
<l>return ()</l>
</body>
<docu id="p_disp_text_left_of_center">
<short lang="de_DE">Displays text right of the center of two given points.</short>
<short lang="en_US">Displays text right of the center of two given points.</short>
<parameters>
<parameter id="ColFirst"/>
<parameter id="ColSecond"/>
<parameter id="Distance"/>
<parameter id="Phi"/>
<parameter id="RowFirst"/>
<parameter id="RowSecond"/>
<parameter id="Text"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="read_caltab_descr_version">
<interface>
<ic>
<par name="CalTabDescrFile" base_type="ctrl" dimension="0"/>
<par name="CalTabDescrFilePath" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PlateDescriptionVersion" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure reads the calibration plate version</c>
<c>* from its description file.</c>
<c></c>
<c>* Set default</c>
<l>PlateDescriptionVersion := 0</l>
<l>MarkDistance := 0</l>
<l>NumberRows:= 0</l>
<l>NumberCols:= 0</l>
<l>MarkDiameter:=0</l>
<c></c>
<l>if (CalTabDescrFilePath == '')</l>
<l>    EnvHalconRoot := environment('HALCONROOT')</l>
<l>    CalTabDescrFilePath := EnvHalconRoot + '/calib'</l>
<l>else</l>
<l>    CalTabDescrFilePath := regexp_replace(CalTabDescrFilePath,'/*[ ]*$','')</l>
<l>endif</l>
<l>try</l>
<l>    open_file (CalTabDescrFilePath + '/' + CalTabDescrFile, 'input', FileHandle)</l>
<l>catch (Exception)</l>
<l>    throw ('The file ' + CalTabDescrFilePath + '/' + CalTabDescrFile + ' could not be opend.')</l>
<l>    return ()</l>
<l>endtry</l>
<c></c>
<l>IsEOF := 0</l>
<l>while (IsEOF == 0)</l>
<l>    fread_line (FileHandle, OutLine, IsEOF)</l>
<l>    tuple_regexp_replace (OutLine, '\\n', '', Result)</l>
<c>    * Plate type.</c>
<l>    if(PlateDescriptionVersion == 0)</l>
<l>        tuple_regexp_match (Result, 'Plate Description Version*', Matches)</l>
<l>        is_empty (Matches, IsEmpty)</l>
<l>        if (IsEmpty != 1)</l>
<l>            tuple_split (Result, ' ', Splitted)</l>
<l>            PlateDescriptionVersion := Splitted[|Splitted| - 1]</l>
<l>            PlateDescriptionVersion := number(PlateDescriptionVersion)</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>    if(MarkDistance == 0)</l>
<l>        tuple_regexp_match (Result, 'Distance between mark centers', Matches)</l>
<l>        is_empty (Matches, IsEmpty)</l>
<l>        if (IsEmpty != 1)</l>
<l>            tuple_split (Result, ' ', Splitted)</l>
<l>            MarkDistance := Splitted[|Splitted| - 1]</l>
<l>            MarkDistance := number(MarkDistance) * 1000.0</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>    tuple_regexp_match (Result, '#', Matches)</l>
<l>    is_empty (Matches, IsEmpty)</l>
<l>    if (IsEmpty)</l>
<l>        if(NumberRows == 0)</l>
<l>            tuple_regexp_match (Result, 'r ', Matches)</l>
<l>            is_empty (Matches, IsEmpty)</l>
<l>            if (IsEmpty!=1)</l>
<l>                tuple_split (Result, ' ', Splitted)</l>
<l>                NumberRows:= Splitted[|Splitted| - 1]</l>
<l>                NumberRows:= number(NumberRows)</l>
<l>            endif</l>
<l>        endif</l>
<l>        if(NumberCols == 0)</l>
<l>            tuple_regexp_match (Result, 'c ', Matches)</l>
<l>            is_empty (Matches, IsEmpty)</l>
<l>            if (IsEmpty!=1)</l>
<l>                tuple_split (Result, ' ', Splitted)</l>
<l>                NumberCols:= Splitted[|Splitted| - 1]</l>
<l>                NumberCols:= number(NumberCols)</l>
<l>            endif</l>
<l>        endif</l>
<l>        if(MarkDiameter == 0)</l>
<l>            tuple_split (Result, ' ', Matches)</l>
<l>            is_empty (Matches, IsEmpty)</l>
<l>            if (IsEmpty!=1)</l>
<l>                if(is_number(Matches[0]))</l>
<l>                    MarkDiameter:=number(Matches[|Matches| - 1])*1000*2</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endwhile</l>
<l>close_file (FileHandle)</l>
<l>if (PlateDescriptionVersion == 0)</l>
<l>    throw ('Calibration Plate type could not be read out of the description file.\n Please set PlateDescriptionVersion manually.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="read_caltab_descr_version">
<parameters>
<parameter id="CalTabDescrFile"/>
<parameter id="CalTabDescrFilePath"/>
<parameter id="PlateDescriptionVersion"/>
</parameters>
</docu>
</procedure>
<procedure name="is_empty">
<interface>
<ic>
<par name="Tuple" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsEmpty" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsEmpty := false</l>
<l>if (|Tuple| == 0)</l>
<l>    IsEmpty := true</l>
<l>    return ()</l>
<l>endif</l>
<c>* tuple_is_number('',IsNumber) returns 'true' !!</c>
<l>tuple_is_number (Tuple + '0', IsNumber)</l>
<l>if ((IsNumber == 0) or (strlen(Tuple + '0') == 1))</l>
<l>    if (strlen(Tuple) == 0)</l>
<l>        IsEmpty := true</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="is_empty">
<parameters>
<parameter id="IsEmpty"/>
<parameter id="Tuple"/>
</parameters>
</docu>
</procedure>
<procedure name="read_caltab_descr_parameter">
<interface>
<ic>
<par name="CalTabDescrFilePath" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PlateDescriptionVersion" base_type="ctrl" dimension="0"/>
<par name="MarkDiameterInMM" base_type="ctrl" dimension="0"/>
<par name="MarkDistanceInMM" base_type="ctrl" dimension="0"/>
<par name="NumberRows" base_type="ctrl" dimension="0"/>
<par name="NumberCols" base_type="ctrl" dimension="0"/>
<par name="JobPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure reads the calibration plate version</c>
<c>* from its description file.</c>
<c>* Set default</c>
<l>PlateDescriptionVersion := 0</l>
<l>MarkDistanceInMM := 0</l>
<l>NumberRows:= 0</l>
<l>NumberCols:= 0</l>
<l>MarkDiameterInMM:=0</l>
<c></c>
<c></c>
<l>try</l>
<l>    open_file (CalTabDescrFilePath,  'input', FileHandle)</l>
<l>catch (Exception)</l>
<l>    JpbPass:=0</l>
<l>    return ()</l>
<l>endtry</l>
<c></c>
<l>JobPass:=1</l>
<l>IsEOF := 0</l>
<l>while (IsEOF == 0)</l>
<l>    fread_line (FileHandle, OutLine, IsEOF)</l>
<l>    tuple_regexp_replace (OutLine, '\\n', '', Result)</l>
<c>    * Plate type.</c>
<l>    if(PlateDescriptionVersion == 0)</l>
<l>        tuple_regexp_match (Result, 'Plate Description Version*', Matches)</l>
<l>        is_empty (Matches, IsEmpty)</l>
<l>        if (IsEmpty != 1)</l>
<l>            tuple_split (Result, ' ', Splitted)</l>
<l>            PlateDescriptionVersion := Splitted[|Splitted| - 1]</l>
<l>            PlateDescriptionVersion := number(PlateDescriptionVersion)</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>    if(MarkDistanceInMM == 0)</l>
<l>        tuple_regexp_match (Result, 'Distance between mark centers', Matches)</l>
<l>        is_empty (Matches, IsEmpty)</l>
<l>        if (IsEmpty != 1)</l>
<l>            tuple_split (Result, ' ', Splitted)</l>
<l>            MarkDistanceInMM := Splitted[|Splitted| - 1]</l>
<l>            MarkDistanceInMM := number(MarkDistanceInMM) * 1000.0</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>    if(MarkDiameterInMM == 0)</l>
<l>            tuple_regexp_match (Result, 'calibration marks at y', Matches)</l>
<l>            is_empty (Matches, IsEmpty)</l>
<l>            if (IsEmpty != 1)</l>
<l>                fread_line (FileHandle, OutLine, IsEOF)</l>
<l>                tuple_regexp_replace (OutLine, '\\n', '', Result)</l>
<l>                tuple_split (Result, ' ', Matches)</l>
<l>                is_empty (Matches, IsEmpty)</l>
<l>                if (IsEmpty!=1)</l>
<l>                    if(is_number(Matches[0]))</l>
<l>                        MarkDiameterInMM:=number(Matches[|Matches| - 1])*1000*2</l>
<l>                    endif</l>
<l>                endif</l>
<l>            endif</l>
<l>    endif</l>
<c>    </c>
<c>    </c>
<l>    tuple_regexp_match (Result, '#', Matches)</l>
<l>    is_empty (Matches, IsEmpty)</l>
<l>    if (IsEmpty)</l>
<l>        if(NumberRows == 0)</l>
<l>            tuple_regexp_match (Result, 'r ', Matches)</l>
<l>            is_empty (Matches, IsEmpty)</l>
<l>            if (IsEmpty!=1)</l>
<l>                tuple_split (Result, ' ', Splitted)</l>
<l>                NumberRows:= Splitted[|Splitted| - 1]</l>
<l>                NumberRows:= number(NumberRows)</l>
<l>            endif</l>
<l>        endif</l>
<l>        if(NumberCols == 0)</l>
<l>            tuple_regexp_match (Result, 'c ', Matches)</l>
<l>            is_empty (Matches, IsEmpty)</l>
<l>            if (IsEmpty!=1)</l>
<l>                tuple_split (Result, ' ', Splitted)</l>
<l>                NumberCols:= Splitted[|Splitted| - 1]</l>
<l>                NumberCols:= number(NumberCols)</l>
<l>            endif</l>
<l>        endif</l>
<c>        </c>
<l>    endif</l>
<l>endwhile</l>
<l>close_file (FileHandle)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="read_caltab_descr_parameter">
<parameters>
<parameter id="CalTabDescrFilePath">
<default_type>string</default_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="MarkDiameterInMM">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="MarkDistanceInMM">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="NumberCols">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="NumberRows">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PlateDescriptionVersion">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_scara_extern_paramter_stationary">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="RobotTransXInmm" base_type="ctrl" dimension="0"/>
<par name="RobotTransYInmm" base_type="ctrl" dimension="0"/>
<par name="RobotTransZInmm" base_type="ctrl" dimension="0"/>
<par name="RobotRotX" base_type="ctrl" dimension="0"/>
<par name="RobotRotY" base_type="ctrl" dimension="0"/>
<par name="RobotRotZ" base_type="ctrl" dimension="0"/>
<par name="CurrentIndex" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>global tuple GlobalPixelSizeInMPerPixel</l>
<l>global tuple GlobalFileNameInternCamPar</l>
<l>global tuple GlobalFileNameExternCamPar</l>
<l>JobPass := 1</l>
<c></c>
<l>CallInBDevEngine:=1</l>
<l>dev_get_system('engine_environment',SystemInformation)</l>
<l>if(SystemInformation =='HDevelop')</l>
<l>    CallInBDevEngine:=0</l>
<l>endif</l>
<c></c>
<l>try</l>
<l>    read_cam_par(GlobalFileNameInternCamPar,InternCamerParameter)</l>
<l>catch(Exception)</l>
<l>    *gen_cam_par_area_scan_division (Focus, Kappa, Sx, Sy, Width/2.0, Height/2.0, Width, Height, CamParam) </l>
<l>    JobPass := 0</l>
<l>    dev_get_exception_data(Exception, 'error_message',ErrorMsg)</l>
<l>    throw ('Error: Can Not Read Intern Camera Parameter:  ' + GlobalFileNameInternCamPar + ErrorMsg) </l>
<l>endtry</l>
<c></c>
<l>RootDir:='/' + 'RecordingExternCalibrationData'</l>
<l>try</l>
<l>make_dir(RootDir)</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c></c>
<l>if(CurrentIndex=0)</l>
<l>    list_files (RootDir, ['files','recursive'], ExampleFiles)</l>
<l>    for Index := |ExampleFiles| to 1 by -1</l>
<l>         delete_file (ExampleFiles[Index - 1])</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<l>ScoreThreshold:=8.0</l>
<l>NumberEdges:=1</l>
<l>ResultInWorld:=0</l>
<l>*OuterRadius:=23</l>
<l>* find_model_circle (InputImage, OuterRadius, ScoreThreshold, JobPass, Score, ModelColPos, ModelRowPos, ScaleRow, ScaleCol)</l>
<c>*TestMeasureGlasEdge (Image, ScoreThreshold, ResultInWorld, PathCalibData, NumberEdges, JobPass, ModelColPos, ModelColPos)</c>
<l>LeftSide := 0  </l>
<l>RoiLeftStart:=200</l>
<l>RoiLeftWidth:=  1648</l>
<l>RoiRightStart:= 2248</l>
<l>RoiRightWidth:= 1648</l>
<l>EdgeTreshold:=10</l>
<l>Dummy:=1</l>
<l>CameraName:='Camera1'</l>
<l>glas_edge_detection (InputImage, LeftSide, RoiLeftStart, RoiLeftWidth, RoiRightStart, RoiRightWidth, EdgeTreshold, JobPass, CurrentPosInMM, LastPosInMM, DistanceInMM, EdgeResult, SecondEdgeResult, CameraLeft)</l>
<l> ModelColPos:=0</l>
<l> ModelColPos:=CurrentPosInMM</l>
<l>ModelRowPos:=0</l>
<l>if(JobPass)</l>
<l>  RobotTransXInM:=RobotTransXInmm/1000.0</l>
<l>  RobotTransYInM:=RobotTransYInmm/1000.0</l>
<l>  RobotTransZInM:=RobotTransZInmm/1000.0</l>
<l>  create_pose (RobotTransXInM, RobotTransYInM, RobotTransZInM, RobotRotX, RobotRotY, RobotRotZ, 'Rp+T', 'gba', 'point', RobotPose)</l>
<l>  create_pose (ModelColPos, ModelRowPos, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', Model2DPose)  </l>
<l>  FileName:=RootDir + '/RobotPose'   + CurrentIndex$'02'  </l>
<l>  write_pose (RobotPose, FileName)</l>
<l>  FileName:=RootDir + '/Model2DPose' + CurrentIndex$'02' </l>
<l>  write_pose (Model2DPose, FileName)</l>
<l>  FileName:=RootDir + '/RecordImage' + CurrentIndex$'02' </l>
<l>    write_image (InputImage, 'bmp', 0, FileName)</l>
<l>  if(CurrentIndex&gt;2)</l>
<l>        RobotXPos:=[]</l>
<l>        RobotYPos:=[]</l>
<l>        RobotZPos:=[]</l>
<l>        ArrayModelColPos:=[]</l>
<l>        ArrayModelRowPos:=[]</l>
<l>        DataArrayRobotPos:=[]</l>
<l>        NumberCalibObjects:=CurrentIndex+1</l>
<l>        for I := 0 to NumberCalibObjects-1 by 1</l>
<l>                 FileName:=RootDir  + '/RobotPose' + I$'02'</l>
<l>                 read_pose(FileName,RobotPose)</l>
<l>                 RobotXPos[I]:=RobotPose[0]</l>
<l>                 RobotYPos[I]:=RobotPose[1]</l>
<l>                 RobotZPos[I]:=RobotPose[2]</l>
<l>                 WorldZPos:=RobotZPos[I]</l>
<l>                 FileName:=RootDir + '/Model2DPose' + I$'02'</l>
<l>                 read_pose(FileName,Model2DPose)</l>
<l>                 ArrayModelColPos[I]:=Model2DPose[0]</l>
<l>                 ArrayModelRowPos[I]:=Model2DPose[1]</l>
<l>         endfor</l>
<l>         k:=0    </l>
<l>         for I := 0 to NumberCalibObjects-1 by 1</l>
<l>             DataArrayRobotPos[k]:=RobotXPos[I]</l>
<l>             k:=k+1</l>
<l>         endfor</l>
<l>         for I := 0 to NumberCalibObjects-1 by 1</l>
<l>             DataArrayRobotPos[k]:=RobotYPos[I]</l>
<l>             k:=k+1</l>
<l>         endfor</l>
<l>         for I := 0 to NumberCalibObjects-1 by 1</l>
<l>             DataArrayRobotPos[k]:=RobotZPos[I]</l>
<l>             k:=k+1</l>
<l>         endfor</l>
<l>         CalibObjIdx:=0</l>
<l>         *create_calib_data ('calibration_object', 1, 1, CalibDataID)</l>
<l>         create_calib_data ('hand_eye_scara_stationary_cam', 1, 1, CalibDataID)</l>
<l>         set_calib_data_cam_param (CalibDataID, 0, [], InternCamerParameter)</l>
<l>         set_calib_data_calib_object (CalibDataID, CalibObjIdx,DataArrayRobotPos)</l>
<l>         create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', StartPose)</l>
<l>         set_calib_data_observ_points (CalibDataID, 0, CalibObjIdx, 0, ArrayModelRowPos,ArrayModelColPos, 'all',StartPose)</l>
<c>         </c>
<l>         set_calib_data (CalibDataID, 'camera', 'general', 'excluded_settings', 'all')</l>
<l>         try</l>
<l>         calibrate_cameras (CalibDataID, Errors)</l>
<l>         Error:=Errors[0]</l>
<l>         catch(Exception)</l>
<l>             dev_get_exception_data(Exception, 'error_message',ErrorMsg)</l>
<l>             throw ('Can Not Calibrate: ' + ErrorMsg) </l>
<l>         endtry</l>
<l>         *get_calib_data (CalibDataID, 'camera', 0, 'params', CalibCameraParameters)</l>
<l>         *write_cam_par (CalibCameraParameters, PathAndFileNameCalibInternParameter)</l>
<l>         get_calib_data (CalibDataID, 'calib_obj_pose', [0,0], 'pose', CameraPose)</l>
<l>         set_origin_pose(CameraPose, 0, 0, WorldZPos, ExternCameraParameter)</l>
<l>         write_pose (ExternCameraParameter, GlobalFileNameExternCamPar)</l>
<l>        calculate_pixel_size (InputImage, InternCamerParameter, ExternCameraParameter, JobPass, PixelSizeInX, PixelSizeInY)</l>
<l>         clear_calib_data(CalibDataID)</l>
<c>         </c>
<l>         Message := ['Back projection error = ' + Error$'.3f' + ' px']</l>
<l>        calculate_pixel_size (InputImage, InternCamerParameter, ExternCameraParameter, JobPass, PixelSizeInX1, PixelSizeInY1)</l>
<l>         if(JobPass)</l>
<l>             Message := Message + ['PixelSize = ' + GlobalPixelSizeInMPerPixel$'.5f' + ' m/px']</l>
<l>         endif</l>
<l>         ColorRes := gen_tuple_const(|Message|,'blue')</l>
<l>         RowTextPosStart:=0</l>
<l>         ColumnTextPosStart:=0</l>
<c>         *draw_text_message_BDevEngine (Message, ColorRes, RowTextPosStart, ColumnTextPosStart)</c>
<l>  endif</l>
<c>    </c>
<l>else</l>
<l>       if( CallInBDevEngine == 0)</l>
<l>        get_image_size (InputImage, ImageWidth, ImageHeight)</l>
<l>          dev_disp_text ('Error: Calibration Pattern Not Found ', 'window', ImageHeight/2,10, 'red','box',true)</l>
<l>       else</l>
<l>           throw ('Error: Calibration Pattern Not Found') </l>
<l>       endif</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="calibrate_scara_extern_paramter_stationary">
<parameters>
<parameter id="CurrentIndex">
<default_type>integer</default_type>
<default_value>0</default_value>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="InputImage"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="RobotRotX">
<default_type>real</default_type>
<default_value>0.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RobotRotY">
<default_type>real</default_type>
<default_value>0.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RobotRotZ">
<default_type>real</default_type>
<default_value>0.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RobotTransXInmm">
<default_type>real</default_type>
<default_value>0.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RobotTransYInmm">
<default_type>real</default_type>
<default_value>0.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RobotTransZInmm">
<default_type>real</default_type>
<default_value>500.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="find_model_circle">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Radius" base_type="ctrl" dimension="0"/>
<par name="Threshold" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="Score" base_type="ctrl" dimension="0"/>
<par name="Xpos" base_type="ctrl" dimension="0"/>
<par name="Ypos" base_type="ctrl" dimension="0"/>
<par name="ScaleRow" base_type="ctrl" dimension="0"/>
<par name="ScaleCol" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>JobPass := 0</l>
<l>RadiusCircle := Radius</l>
<l>SizeSynthImage := 2 * RadiusCircle + 10</l>
<l>gen_ellipse_contour_xld (Circle, SizeSynthImage / 2, SizeSynthImage / 2, 0, RadiusCircle, RadiusCircle, 0, 6.28318, 'positive', 1.5)</l>
<l>gen_image_const (EmptyImage, 'byte', SizeSynthImage, SizeSynthImage)</l>
<l>gen_image_proto(EmptyImage,EmptyImage,255)</l>
<l>paint_xld (Circle, EmptyImage, SyntheticModelImage, 0)</l>
<l>create_generic_shape_model (ModelID)</l>
<l>set_generic_shape_model_param (ModelID, 'iso_scale_min', 0.8)</l>
<l>set_generic_shape_model_param (ModelID, 'iso_scale_max', 1.2)</l>
<l>train_generic_shape_model (SyntheticModelImage, ModelID)</l>
<l>get_generic_shape_model_object (ShapeModel, ModelID, 'contours')</l>
<c></c>
<l>set_generic_shape_model_param (ModelID, 'min_score', Threshold)</l>
<l>find_generic_shape_model (InputImage, ModelID, MatchResultID, NumMatchResult)</l>
<l>if (NumMatchResult &gt; 0)</l>
<l>    dev_display (InputImage)</l>
<l>    get_generic_shape_model_result_object (Objects, MatchResultID, 'best', 'contours')</l>
<l>    area_center_xld(Objects, Area, Row, Column,pointOrder)</l>
<l>    *area_center(Objects,Area, Row, Column)</l>
<l>    *get_generic_shape_model_result (MatchResultID, 'best', 'row', Row)</l>
<l>    *get_generic_shape_model_result (MatchResultID, 'best', 'column', Column)</l>
<l>    get_generic_shape_model_result (MatchResultID, 'best', 'score', Score)</l>
<l>    get_generic_shape_model_result (MatchResultID, 'best', 'scale_row', ScaleRow)</l>
<l>    get_generic_shape_model_result (MatchResultID, 'best', 'scale_column', ScaleCol)</l>
<l>    Xpos := Column</l>
<l>    Ypos := Row</l>
<l>    JobPass := 1</l>
<l>    CrossLenght2:=SizeSynthImage / 2</l>
<l>    gen_region_line(RegionLinesH,Row, Column-CrossLenght2, Row, Column+CrossLenght2)</l>
<l>    gen_region_line(RegionLinesV,Row-CrossLenght2, Column, Row+CrossLenght2, Column)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display(RegionLinesH)</l>
<l>    dev_display(RegionLinesV)</l>
<l>    *dev_display (Objects)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="find_model_circle">
<parameters>
<parameter id="InputImage">
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
<parameter id="Radius">
<default_type>integer</default_type>
<default_value>23</default_value>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_list>
<item>23</item>
</value_list>
</parameter>
<parameter id="ScaleCol"/>
<parameter id="ScaleRow"/>
<parameter id="Score">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Threshold">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Xpos">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Ypos">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_pixel_size">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="InternCameraParameter" base_type="ctrl" dimension="0"/>
<par name="ExternCameraParameter" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="PixelSizeInX" base_type="ctrl" dimension="0"/>
<par name="PixelSizeInY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>JobPass:=0</l>
<c>* Transform the image border into the WCS (scale = 1)</c>
<l>get_image_size(InputImage,Width,Height)</l>
<l>full_domain (InputImage, ImageFull)</l>
<l>get_domain (ImageFull, Domain)</l>
<l>gen_contour_region_xld (Domain, ImageBorder, 'border')</l>
<l>contour_to_world_plane_xld (ImageBorder, ImageBorderWCS, InternCameraParameter, ExternCameraParameter, 'm')</l>
<l>smallest_rectangle1_xld (ImageBorderWCS, MinY, MinX, MaxY, MaxX)</l>
<c>* Determine the scale of the mapping</c>
<l>ExtentX := MaxX - MinX</l>
<l>ExtentY := MaxY - MinY</l>
<l>ScaleX := ExtentX / Width</l>
<l>ScaleY := ExtentY / Height</l>
<l>PixelSizeInX:=ScaleX</l>
<l>PixelSizeInY:=ScaleY</l>
<c></c>
<l>JobPass:=1</l>
<l>return ()</l>
</body>
<docu id="calculate_pixel_size">
<parameters>
<parameter id="ExternCameraParameter"/>
<parameter id="InputImage"/>
<parameter id="InternCameraParameter"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="PixelSizeInX">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PixelSizeInY">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="find_model_circle_in_world_coor">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DiameterInMM" base_type="ctrl" dimension="0"/>
<par name="PathCalibData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="XPosInMM" base_type="ctrl" dimension="0"/>
<par name="YPosInMM" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>global tuple GlobalPixelSizeInMPerPixel</l>
<l>global tuple GlobalFileNameInternCamPar</l>
<l>global tuple GlobalFileNameExternCamPar</l>
<l>JobPass:=1</l>
<c></c>
<l>try</l>
<l>FileNameInternCamPar:=GlobalFileNameInternCamPar</l>
<l>FileNameExternCamPar:=GlobalFileNameExternCamPar</l>
<l>catch(Exection)</l>
<l>    GlobalFileNameInternCamPar:='InternCameraParameter.dat'</l>
<l>    GlobalFileNameExternCamPar:='ExternCameraParameter.dat'</l>
<l>    FileNameInternCamPar:=GlobalFileNameInternCamPar</l>
<l>    FileNameExternCamPar:=GlobalFileNameExternCamPar</l>
<l>endtry</l>
<l>PathAndFileNameInternParameter := PathCalibData + '/' + FileNameInternCamPar</l>
<l>PathAndFileNameExternParameter := PathCalibData + '/' + FileNameExternCamPar</l>
<l>read_cam_par(PathAndFileNameInternParameter,InternCamerParameter)</l>
<l>read_pose(PathAndFileNameExternParameter,ExternCameraParameter)</l>
<l>CameraName:='Camera1'</l>
<l>get_line_size_in_millimeter_stripe_position (InputImage, JobPass, PixelSizeInMPerPixel)</l>
<c></c>
<l>if(JobPass and PixelSizeInMPerPixel&gt;0)</l>
<l>    ScoreThreshold:=0.7</l>
<l>    DiameterInM:=DiameterInMM/1000.0</l>
<l>    OuterRadius:=(DiameterInM/PixelSizeInMPerPixel)/2.0</l>
<l>    find_model_circle (InputImage, OuterRadius, ScoreThreshold, JobPass, Score, ModelColPos, ModelRowPos, ScaleRow, ScaleCol)</l>
<l>    if(JobPass)</l>
<l>        image_points_to_world_plane (InternCamerParameter, ExternCameraParameter, ModelRowPos, ModelColPos, 'm', XPosInMM, YPosInMM) </l>
<l>*        pose_to_hom_mat3d (ExternCameraParameter, HomMat3D)</l>
<l>*        affine_trans_point_3d (HomMat3D, XPosInMM, YPosInMM, 0, x, y, z)</l>
<l>*        project_3d_point (x, y, z, InternCamerParameter, Row, Column)</l>
<c>       </c>
<l>       Text := ['XPos= ' + (ModelColPos)$'.3f' + ' pix ' , 'YPos= ' + ( ModelRowPos)$'.3f' + ' pix ']</l>
<l>       ColorRes := gen_tuple_const(|Text|,'blue')</l>
<c>       *draw_text_message_BDevEngine (Text, ColorRes, ModelRowPos, ModelColPos)</c>
<l>       XPosInMM:=XPosInMM*1000.0</l>
<l>       YPosInMM:=YPosInMM*1000.0</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="find_model_circle_in_world_coor">
<parameters>
<parameter id="DiameterInMM">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="InputImage"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="PathCalibData">
<default_type>string</default_type>
<default_value>d:/CalibrationData</default_value>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="XPosInMM">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="YPosInMM">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_line_size_in_millimeter_stripe_position">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="LineSizeInMillimeter" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>JobPass := 0</l>
<l>SubName:='StripePosition'</l>
<l>FileNameInternCamPar := SubName + 'InternalCameraParameter.dat'</l>
<l>try</l>
<l>    read_cam_par(FileNameInternCamPar,InternCamerParameter)</l>
<l>    LineSizeInMillimeter := InternCamerParameter[10]*1000.0</l>
<l>    JobPass := 1</l>
<l>catch(Exception)</l>
<c>    *hier noch keine Kalibrierdaten vorhanden, Rückgabe Startwert</c>
<l>    JobPass := 1</l>
<l>    FileNameInternCamPar := SubName + 'StartParamterCalibration.tup'</l>
<l>    try</l>
<l>     read_tuple(FileNameInternCamPar,StartParamter)</l>
<l>     LineSizeInMillimeter:=StartParamter[0]</l>
<l>    catch(Exception)</l>
<l>     LineSizeInMillimeter := 0.354</l>
<l>     write_tuple(LineSizeInMillimeter,FileNameInternCamPar)</l>
<l>    endtry</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="get_line_size_in_millimeter_stripe_position">
<parameters>
<parameter id="Image"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="LineSizeInMillimeter">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="glas_edge_detection">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="LeftSide" base_type="ctrl" dimension="0"/>
<par name="RoiLeftOffsetInMM" base_type="ctrl" dimension="0"/>
<par name="RoiLeftWidthInMM" base_type="ctrl" dimension="0"/>
<par name="RoiRightOffsetInMM" base_type="ctrl" dimension="0"/>
<par name="RoiRightWidthInMM" base_type="ctrl" dimension="0"/>
<par name="EdgeThreshold" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="CurrentPosInMM" base_type="ctrl" dimension="0"/>
<par name="LastPosInMM" base_type="ctrl" dimension="0"/>
<par name="DistanceInMM" base_type="ctrl" dimension="0"/>
<par name="EdgeResult" base_type="ctrl" dimension="0"/>
<par name="EdgeSecondResult" base_type="ctrl" dimension="0"/>
<par name="CameraLeft" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*Kameraparameter nur einmal laden</c>
<l>global tuple GlobalExternCameraParameter</l>
<l>global tuple GlobalInternCameraParameter</l>
<c></c>
<l>global tuple GlobalLastPosInMM</l>
<l>global tuple GlobalToggelVar</l>
<c></c>
<l>JobPass := 0</l>
<c>*GlobalToggelVar nur zum Testen</c>
<l>try</l>
<l>if(GlobalToggelVar == 0)</l>
<l>    GlobalToggelVar := 1</l>
<l>else</l>
<l>   GlobalToggelVar := 0 </l>
<l>endif</l>
<l>catch(Exseption)</l>
<l>    GlobalToggelVar := 0 </l>
<l>endtry</l>
<c></c>
<l>FileNameInternalCamParameter:='StripePosition'+'InternalCameraParameter.dat'</l>
<l>FileNameExternalCamParameter:='StripePosition'+'ExternalCameraParameter.dat'</l>
<c>*Einmaliges Einlesen der internen und externen Kameraparamter</c>
<l>try</l>
<l>        num:=|GlobalExternCameraParameter|</l>
<l>        if(num==0)</l>
<c>            *Neue Kalibrierdaten vorhanden, dann neu laden</c>
<l>            throw('Read New')</l>
<l>        endif</l>
<l>catch (Exception)</l>
<l>        try</l>
<l>            read_pose(FileNameExternalCamParameter,GlobalExternCameraParameter)</l>
<l>        catch(Exception)</l>
<l>            dev_get_exception_data(Exception, 'error_message',ErrorMsg)</l>
<l>            throw ('Measure Glas Edge Not Possible. Can Not Read Extern Camera Parameter: ' + ErrorMsg) </l>
<l>            return()</l>
<l>        endtry</l>
<l>endtry</l>
<l>try</l>
<l>        num:=|GlobalInternCameraParameter|</l>
<l>        if(num==0)</l>
<c>            *Neue Kalibrierdaten vorhanden, dann neu laden</c>
<l>            throw('Read New')</l>
<l>        endif</l>
<l>catch(Exception)</l>
<l>        try</l>
<l>            read_cam_par(FileNameInternalCamParameter,GlobalInternCameraParameter)</l>
<l>        catch(Exception)</l>
<l>            dev_get_exception_data(Exception, 'error_message',ErrorMsg)</l>
<l>            throw ('Measure Glas Edge Not Possible. Can Not Read Intern Camera Parameter: ' + ErrorMsg) </l>
<l>            return()</l>
<l>        endtry</l>
<l>endtry </l>
<l>get_image_size (Image, Width, Height)</l>
<c>*Lese Vy aus den internen Kameraparamter. Einheit ist mm/pix</c>
<l>PixelSize := GlobalInternCameraParameter[10]*1000.0</l>
<c>*Daten sind in mm angegeben umrechen nach Pixel</c>
<l>RoiLeftWidthInPixel := RoiLeftWidthInMM/PixelSize</l>
<l>RoiRightWidthInPixel := RoiRightWidthInMM/PixelSize</l>
<c></c>
<l>RoiLeftOffsetInPixel := RoiLeftOffsetInMM/PixelSize</l>
<l>RoiRightOffsetInPixel := RoiRightOffsetInMM/PixelSize</l>
<c></c>
<l>RoiLeftOffsetInPixel := Width/2 - (RoiLeftOffsetInPixel + RoiLeftWidthInPixel)</l>
<l>RoiRightOffsetInPixel := Width/2 + RoiRightOffsetInPixel</l>
<c></c>
<c>*Sicherstellen das die Grenzen nicht überschritten</c>
<l>if ((RoiLeftOffsetInPixel + RoiLeftWidthInPixel) &gt;= Width)</l>
<l>    RoiLeftOffsetInPixel := 0</l>
<l>    RoiLeftWidthInPixel := Width/2 -1</l>
<l>endif</l>
<c></c>
<l>if ((RoiRightOffsetInPixel + RoiRightWidthInPixel) &gt;= Width)</l>
<l>    RoiRightOffsetInPixel := Width/2</l>
<l>    RoiRightWidthInPixel := Width/2 -1</l>
<l>endif</l>
<c></c>
<l>Lenght2 := Height/2</l>
<l>RoiCenterRow := Lenght2</l>
<l>Interpolation := 'nearest_neighbor'</l>
<c>*Leftside größer eins dient nur zum Testen, beide Lichter an, dann nur z.B. A4 Blatt vermessen</c>
<l>if(LeftSide&gt;1)</l>
<l>LeftSide := GlobalToggelVar</l>
<l>endif</l>
<c>*CameraLeft Zugehörikeit der Messung. Zusätzlich Information für die SPS</c>
<l>CameraLeft := LeftSide</l>
<l>if(LeftSide==0)</l>
<c>   *Kante auf der rechten Seite suchen. Suchrichtung der Kante ist hier von rechts nach links</c>
<l>    Phi := rad(-180)</l>
<l>    RoiCenterColumn := RoiRightWidthInPixel/2 + RoiRightOffsetInPixel - 1</l>
<l>    Lenght1 := RoiRightWidthInPixel/2</l>
<c>   *Dient nur zum Einzeichnen</c>
<l>    gen_rectangle2 (Rectangle,RoiCenterRow, RoiCenterColumn, Phi, Lenght1, Lenght2)</l>
<c>   *Messfensterobjekt erzeugen</c>
<l>    gen_measure_rectangle2 (RoiCenterRow, RoiCenterColumn, Phi, Lenght1, Lenght2, Width, Height, Interpolation, MeasureHandle)</l>
<l>else</l>
<c>   *Kante auf der linken Seite suchen. Suchrichtung der Kante ist hier von links nach rechts</c>
<l>    Phi := rad(0)</l>
<l>    RoiCenterColumn := RoiLeftOffsetInPixel + RoiLeftWidthInPixel/2 - 1</l>
<l>    Lenght1 := RoiLeftWidthInPixel/2</l>
<c>   *Dient nur zum einzeichnen</c>
<l>    gen_rectangle2 (Rectangle,RoiCenterRow, RoiCenterColumn, Phi, Lenght1, Lenght2)</l>
<c>   *Messfensterobjekt erzeugen</c>
<l>    gen_measure_rectangle2 (RoiCenterRow, RoiCenterColumn, Phi, Lenght1, Lenght2, Width, Height, Interpolation, MeasureHandle)</l>
<l>endif</l>
<c></c>
<l>reduce_domain(Image, Rectangle, RoiImage)</l>
<c>*Bildvorverarbeitung Histogrammspeizung und Kontrastverbesserung</c>
<l>emphasize(RoiImage,RoiImage,13,3,3)</l>
<l>equ_histo_image(RoiImage,RoiImage)</l>
<c>*Vorverarbeitetes Bild/Messfenster einzeichnen</c>
<l>overpaint_gray(Image,RoiImage)</l>
<l>*dev_display (Image)</l>
<c></c>
<c>*Zur Orientierung Kameramittenposition einzeichnen</c>
<l>gen_region_line(MiddleLine,0, Width/2, Height-1,  Width/2)</l>
<l>dev_set_color('spring green')</l>
<l>dev_display (MiddleLine)</l>
<c></c>
<c>*Messfensterrahmen einzeichnen</c>
<l>dev_set_color('yellow')</l>
<l>dev_set_draw('margin')</l>
<l>dev_set_line_width(4)</l>
<l>dev_display (Rectangle)</l>
<c></c>
<l>Sigma := 2.5</l>
<c>*Suche Kante von dunkel nach hell</c>
<l>Transition := 'positive'</l>
<c>*Alle Kanten ausgeben die oberhalb der Schwelle(EdgeThreshold) liegen</c>
<l>Select := 'all'  </l>
<l>measure_pos (Image, MeasureHandle, Sigma, EdgeThreshold, Transition, Select, RowEdge, ColumnEdge, Amplitude, Distance)</l>
<l>if(|RowEdge|&gt; 0)</l>
<l>    JobPass :=1</l>
<l>    MaxValue:=0</l>
<l>    ResultIndex:=0</l>
<l>    EdgeSecondResult := -1</l>
<c>    *Die Kante heraussuchen mit der größten Amplitude</c>
<l>    for Index := 0 to |RowEdge|-1 by 1</l>
<l>        if(Amplitude[Index]&gt;MaxValue)</l>
<l>           MaxValue := Amplitude[Index] </l>
<l>           ResultIndex := Index</l>
<l>        endif</l>
<l>    endfor</l>
<l>    EdgeResult := Amplitude[ResultIndex]</l>
<c>    * Kantenposition einzeichnen</c>
<l>    gen_cross_contour_xld(Cross,RowEdge[ResultIndex], ColumnEdge[ResultIndex], 80, rad(45))</l>
<l>    dev_set_line_width(6)</l>
<l>    dev_display (Cross)</l>
<c>    * Vorgabe Weltkoordinaten Xw=0 Yw=0 Zw=0 dann Berechnung Zeilenposition(Row0)</c>
<l>    pose_to_hom_mat3d (GlobalExternCameraParameter, CCS_HomMat_WCS)</l>
<c>    * Transformormation Weltkoordinaten in Kamerakoordinaten</c>
<l>    affine_trans_point_3d (CCS_HomMat_WCS, 0, 0, 0, CCS_X, CCS_Y, CCS_Z)</l>
<c>    * Transformation Kamerakoordinaten zu Bildkoordinaten</c>
<l>    project_3d_point (CCS_X, CCS_Y, CCS_Z, GlobalInternCameraParameter, Row0, Column0)</l>
<c>    * Lege Nullposition auf Kameramittenpunkt  </c>
<l>    Column0 := Width/2</l>
<l>    image_points_to_world_plane(GlobalInternCameraParameter, GlobalExternCameraParameter, Row0, ColumnEdge[ResultIndex], 'mm', CurrentXposInMM, CurrentYposInMM)</l>
<l>    image_points_to_world_plane(GlobalInternCameraParameter, GlobalExternCameraParameter, Row0, Column0, 'mm', CenterXposInMM, CenterYposInMM)</l>
<c>     </c>
<l>    *image_points_to_world_plane(GlobalInternCameraParameter, GlobalExternCameraParameter, RowEdge[ResultIndex], ColumnEdge[ResultIndex], 'mm', CurrentXposInMM, CurrentYposInMM)</l>
<l>    *image_points_to_world_plane(GlobalInternCameraParameter, GlobalExternCameraParameter, RowEdge[ResultIndex], Column0, 'mm', CenterXposInMM, CenterYposInMM)</l>
<c>    *Suche zweitgrößte Kante wenn vorhanden dient nur zur Kontrolle/Vergleich</c>
<l>    Text := 'PosInPix: ' + ColumnEdge[ResultIndex]$'.1f'</l>
<l>    dev_disp_text (Text, 'image', 1, 10, 'yellow','box',false)</l>
<l>    MaxValue := 0</l>
<l>    ResultIndexSecondEdge := 0</l>
<l>    if(|RowEdge|&gt;1)</l>
<l>        Amplitude[ResultIndex] := 0</l>
<l>        for Index := 0 to |RowEdge|-1 by 1</l>
<l>             if(Amplitude[Index]&gt;MaxValue)</l>
<l>               MaxValue := Amplitude[Index] </l>
<l>               ResultIndexSecondEdge := Index</l>
<l>             endif</l>
<l>        endfor</l>
<l>        EdgeSecondResult := Amplitude[ResultIndexSecondEdge]</l>
<c>        *Kantenposition einzeichnen zweithöchste Amplitude, dient dazu die Kantenschwelle einzustellen</c>
<l>        gen_cross_contour_xld(Cross,RowEdge[ResultIndexSecondEdge], ColumnEdge[ResultIndexSecondEdge], 40, rad(45))</l>
<l>        dev_display (Cross)</l>
<l>    endif</l>
<c>    </c>
<l>     try</l>
<l>         LastPosInMM := GlobalLastPosInMM</l>
<l>     catch(Exception)</l>
<l>         DistanceInMM := -1</l>
<l>         LastPosInMM := -1</l>
<l>     endtry</l>
<l>     distance_pp (CenterXposInMM, CenterYposInMM, CurrentXposInMM, CurrentYposInMM, CurrentPosInMM)</l>
<l>     if(ColumnEdge[ResultIndex] &gt; Column0)</l>
<l>         EdgeIsOnRightSide := 1</l>
<l>     else</l>
<l>         EdgeIsOnRightSide := 0</l>
<l>     endif</l>
<l>     if(EdgeIsOnRightSide==0)</l>
<c>         *Kante ist auf der linken Seite, dann negieren, Koordinatensystem für die SPS</c>
<l>        CurrentPosInMM := CurrentPosInMM *(-1.0) </l>
<l>     endif</l>
<c>     *Aktuelle Position als Letzte speichern</c>
<l>     GlobalLastPosInMM := CurrentPosInMM</l>
<c>     *Distanzmessung dient nur zur Kontrolle bzw zum Testen</c>
<l>     if(LastPosInMM != -1)</l>
<l>         if((LastPosInMM &lt; 0 and CurrentPosInMM &lt; 0) or ((LastPosInMM &gt; 0 and CurrentPosInMM &gt; 0)))</l>
<c>             *Beide Kanten befinden sich auf der linken oder rechten Seite</c>
<l>            DistanceInMM := abs(abs(LastPosInMM) - abs(CurrentPosInMM))  </l>
<l>         else</l>
<c>             *Eine Kante befindet sich auf der linken Seite und die andere auf rechten Seite</c>
<l>            DistanceInMM := abs(LastPosInMM) + abs(CurrentPosInMM)  </l>
<l>         endif</l>
<l>     endif</l>
<l>endif</l>
<c>*dev_set_part(0, RoiCenterColumn-Lenght1, Height-1, RoiCenterColumn+Lenght1)</c>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="glas_edge_detection">
<parameters>
<parameter id="CameraLeft">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="CurrentPosInMM">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DistanceInMM">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="EdgeResult">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="EdgeSecondResult">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="EdgeThreshold">
<default_type>integer</default_type>
<default_value>40</default_value>
<type_list>
<item>integer</item>
</type_list>
<value_max>255</value_max>
</parameter>
<parameter id="Image"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="LastPosInMM">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="LeftSide">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>integer</item>
</type_list>
<value_max>2</value_max>
<value_min>0</value_min>
</parameter>
<parameter id="RoiLeftOffsetInMM">
<default_type>real</default_type>
<default_value>50.0</default_value>
<type_list>
<item>real</item>
</type_list>
<value_max>600.000000</value_max>
<value_min>-600.000000</value_min>
</parameter>
<parameter id="RoiLeftWidthInMM">
<default_type>real</default_type>
<default_value>300.0</default_value>
<type_list>
<item>real</item>
</type_list>
<value_max>1200.000000</value_max>
<value_min>0</value_min>
</parameter>
<parameter id="RoiRightOffsetInMM">
<default_type>real</default_type>
<default_value>50.0</default_value>
<type_list>
<item>real</item>
</type_list>
<value_max>600.000000</value_max>
<value_min>-600.000000</value_min>
</parameter>
<parameter id="RoiRightWidthInMM">
<default_type>real</default_type>
<default_value>300.0</default_value>
<type_list>
<item>real</item>
</type_list>
<value_max>1200.000000</value_max>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="list_image_files">
<interface>
<ic>
<par name="ImageDirectory" base_type="ctrl" dimension="0"/>
<par name="Extensions" base_type="ctrl" dimension="0"/>
<par name="Options" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure returns all files in a given directory</c>
<c>* with one of the suffixes specified in Extensions.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* ImageDirectory: Directory or a tuple of directories with images.</c>
<c>*    If a directory is not found locally, the respective directory</c>
<c>*    is searched under %HALCONIMAGES%/ImageDirectory.</c>
<c>*    See the Installation Guide for further information</c>
<c>*    in case %HALCONIMAGES% is not set.</c>
<c>* Extensions: A string tuple containing the extensions to be found</c>
<c>*    e.g. ['png','tif',jpg'] or others</c>
<c>* If Extensions is set to 'default' or the empty string '',</c>
<c>*    all image suffixes supported by HALCON are used.</c>
<c>* Options: as in the operator list_files, except that the 'files'</c>
<c>*    option is always used. Note that the 'directories' option</c>
<c>*    has no effect but increases runtime, because only files are</c>
<c>*    returned.</c>
<c>* </c>
<c>* Output parameter:</c>
<c>* ImageFiles: A tuple of all found image file names</c>
<c>* </c>
<l>if (Extensions == [] or Extensions == '' or Extensions == 'default')</l>
<l>    Extensions := ['ima', 'tif', 'tiff', 'gif', 'bmp', 'jpg', 'jpeg', 'jp2', 'jxr', 'png', 'pcx', 'ras', 'xwd', 'pbm', 'pnm', 'pgm', 'ppm']</l>
<c>    * </c>
<l>endif</l>
<l>ImageFiles := []</l>
<c>* Loop through all given image directories.</c>
<l>for ImageDirectoryIndex := 0 to |ImageDirectory| - 1 by 1</l>
<l>    ImageFilesTmp := []</l>
<l>    CurrentImageDirectory := ImageDirectory[ImageDirectoryIndex]</l>
<l>    if (CurrentImageDirectory == '')</l>
<l>        CurrentImageDirectory := '.'</l>
<l>    endif</l>
<l>    get_system ('image_dir', HalconImages)</l>
<l>    get_system ('operating_system', OS)</l>
<l>    if (OS{0:2} == 'Win')</l>
<l>        HalconImages := split(HalconImages,';')</l>
<l>    else</l>
<l>        HalconImages := split(HalconImages,':')</l>
<l>    endif</l>
<l>    Directories := CurrentImageDirectory</l>
<l>    for Index := 0 to |HalconImages| - 1 by 1</l>
<l>        Directories := [Directories,HalconImages[Index] + '/' + CurrentImageDirectory]</l>
<l>    endfor</l>
<l>    tuple_strlen (Directories, Length)</l>
<l>    tuple_gen_const (|Length|, false, NetworkDrive)</l>
<l>    if (OS{0:2} == 'Win')</l>
<l>        for Index := 0 to |Length| - 1 by 1</l>
<l>            if (strlen(Directories[Index]) &gt; 1)</l>
<l>                tuple_str_first_n (Directories[Index], 1, Substring)</l>
<l>                if (Substring == '//' or Substring == '\\\\')</l>
<l>                    NetworkDrive[Index] := true</l>
<l>                endif</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>    ImageFilesTmp := []</l>
<l>    for Index := 0 to |Directories| - 1 by 1</l>
<l>        file_exists (Directories[Index], FileExists)</l>
<l>        if (FileExists)</l>
<l>            list_files (Directories[Index], ['files',Options], AllFiles)</l>
<l>            ImageFilesTmp := []</l>
<l>            for i := 0 to |Extensions| - 1 by 1</l>
<l>                tuple_regexp_select (AllFiles, ['.*' + Extensions[i] + '$','ignore_case'], Selection)</l>
<l>                ImageFilesTmp := [ImageFilesTmp,Selection]</l>
<l>            endfor</l>
<l>            tuple_regexp_replace (ImageFilesTmp, ['\\\\', 'replace_all'], '/', ImageFilesTmp)</l>
<l>            if (NetworkDrive[Index])</l>
<l>                tuple_regexp_replace (ImageFilesTmp, ['//', 'replace_all'], '/', ImageFilesTmp)</l>
<l>                ImageFilesTmp := '/' + ImageFilesTmp</l>
<l>            else</l>
<l>                tuple_regexp_replace (ImageFilesTmp, ['//', 'replace_all'], '/', ImageFilesTmp)</l>
<l>            endif</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Concatenate the output image paths.</c>
<l>    ImageFiles := [ImageFiles,ImageFilesTmp]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="list_image_files">
<abstract lang="en_US">This procedure returns all files in a given directory ImageDirectory with one of the suffixes specified in Extensions.

It is possible to use a tuple with multiple directories as input ImageDirectory. If a directory is not found locally, the respective directory is searched under %HALCONIMAGES%/ImageDirectory. See the `Installation Guide` for further information in case %HALCONIMAGES% is not set.

If Extensions is set to *'default'* or the empty string *''*, all image suffixes supported by HALCON are used.

The parameter Options is used as in the operator &lt;op:list_files&gt; (see &lt;op:list_files&gt; for details), except that the *'files'* option is always used. Note that the *'directories'* option has no effect but increases runtime, because only files are returned.</abstract>
<alternatives>
<item>list_files</item>
</alternatives>
<chapters lang="de_DE">
<item>Datei</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<chapters lang="ja_JP">
<item>ファイル</item>
<item>その他</item>
</chapters>
<example lang="en_US">list_image_files ('.',[] ,[] , ImageFiles)
for Index := 1 to |ImageFiles|  by 1
    read_image (Image,ImageFiles[Index-1])
*     do something
endfor</example>
<keywords lang="de_DE">
<item>Bilddateien auflisten</item>
</keywords>
<keywords lang="en_US">
<item>list image files</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>list_files</item>
</predecessor>
<see_also>
<item>list_files</item>
</see_also>
<short>Get all image files under the given path</short>
<short lang="en_US">Get all image files under the given path</short>
<successor>
<item>read_image</item>
</successor>
<parameters>
<parameter id="Extensions">
<default_type>string</default_type>
<default_value>'default'</default_value>
<description lang="en_US">A string tuple containing the extensions to be found e.g. ['png','tif',jpg'] or others</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'ima'</item>
<item>'bmp'</item>
<item>'jpg'</item>
<item>'png'</item>
<item>'tiff'</item>
<item>'tif'</item>
<item>'gif'</item>
<item>'jpeg'</item>
<item>'pcx'</item>
<item>'pgm'</item>
<item>'ppm'</item>
<item>'pbm'</item>
<item>'xwd'</item>
<item>'pnm'</item>
</values>
</parameter>
<parameter id="ImageDirectory">
<default_type>string</default_type>
<description lang="en_US">The image directory</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">A tuple of all found image file names</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.read</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Options">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Processing options</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'recursive'</item>
<item>'follow_links'</item>
<item>'max_depth 5'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_data">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
<par name="ParamName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_data returns in ParamValue the value of the</c>
<c>* parameter that is given in ParamName from the tuple of</c>
<c>* camera parameters that is given in CameraParam.</c>
<c>* </c>
<c>* Get the parameter names that correspond to the</c>
<c>* elements in the input camera parameter tuple.</c>
<l>get_cam_par_names (CameraParam, CameraType, CameraParamNames)</l>
<c>* </c>
<c>* Find the index of the requested camera data and return</c>
<c>* the corresponding value.</c>
<l>ParamValue := []</l>
<l>for Index := 0 to |ParamName| - 1 by 1</l>
<l>    ParamNameInd := ParamName[Index]</l>
<l>    if (ParamNameInd == 'camera_type')</l>
<l>        ParamValue := [ParamValue,CameraType]</l>
<l>        continue</l>
<l>    endif</l>
<l>    I := find(CameraParamNames,ParamNameInd)</l>
<l>    if (I != -1)</l>
<l>        ParamValue := [ParamValue,CameraParam[I]]</l>
<l>    else</l>
<l>        throw ('Unknown camera parameter ' + ParamNameInd)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_data">
<abstract lang="en_US">&lt;proc:get_cam_par_data&gt; returns the value ParamValue of the camera parameter ParamName from the camera parameter tuple CameraParam. The following parameter names can be queried:
- *'camera_type'*
- *'focus'*
- *'magnification'*
- *'kappa'*
- *'k1'*
- *'k2'*
- *'k3'*
- *'p1'*
- *'p2'*
- *'image_plane_dist'*
- *'tilt'*
- *'rot'*
- *'sx'*
- *'sy'*
- *'cx'*
- *'cy'*
- *'image_width'*
- *'image_height'*
- *'vx'*
- *'vy'*
- *'vz'*.

If the camera type does not support the requested value, an exception is raised.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<chapters lang="ja_JP">
<item>キャリブレーション</item>
<item>カメラパラメーター</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_data (CameraParam, 'image_width', ImageWidth)
get_cam_par_data (CameraParam, 'image_height', ImageHeight)
gen_image_const (Image, 'byte', ImageWidth, ImageHeight)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Get the value of a specified camera parameter from the camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ParamName">
<default_type>string</default_type>
<default_value>'image_width'</default_value>
<description lang="en_US">Name of the camera parameter for that the value should be returned.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'camera_type'</item>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</value_list>
</parameter>
<parameter id="ParamValue">
<default_type>real</default_type>
<description lang="en_US">Value of the requested camera parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_contour_xld">
<interface>
<oo>
<par name="Arrow" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="HeadLength" base_type="ctrl" dimension="0"/>
<par name="HeadWidth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure generates arrow shaped XLD contours,</c>
<c>* pointing from (Row1, Column1) to (Row2, Column2).</c>
<c>* If starting and end point are identical, a contour consisting</c>
<c>* of a single point is returned.</c>
<c>* </c>
<c>* input parameters:</c>
<c>* Row1, Column1: Coordinates of the arrows' starting points</c>
<c>* Row2, Column2: Coordinates of the arrows' end points</c>
<c>* HeadLength, HeadWidth: Size of the arrow heads in pixels</c>
<c>* </c>
<c>* output parameter:</c>
<c>* Arrow: The resulting XLD contour</c>
<c>* </c>
<c>* The input tuples Row1, Column1, Row2, and Column2 have to be of</c>
<c>* the same length.</c>
<c>* HeadLength and HeadWidth either have to be of the same length as</c>
<c>* Row1, Column1, Row2, and Column2 or have to be a single element.</c>
<c>* If one of the above restrictions is violated, an error will occur.</c>
<c>* </c>
<c>* </c>
<c>* Initialization.</c>
<l>gen_empty_obj (Arrow)</l>
<c>* </c>
<c>* Calculate the arrow length</c>
<l>distance_pp (Row1, Column1, Row2, Column2, Length)</l>
<c>* </c>
<c>* Mark arrows with identical start and end point</c>
<c>* (set Length to -1 to avoid division-by-zero exception)</c>
<l>ZeroLengthIndices := find(Length,0)</l>
<l>if (ZeroLengthIndices != -1)</l>
<l>    Length[ZeroLengthIndices] := -1</l>
<l>endif</l>
<c>* </c>
<c>* Calculate auxiliary variables.</c>
<l>DR := 1.0 * (Row2 - Row1) / Length</l>
<l>DC := 1.0 * (Column2 - Column1) / Length</l>
<l>HalfHeadWidth := HeadWidth / 2.0</l>
<c>* </c>
<c>* Calculate end points of the arrow head.</c>
<l>RowP1 := Row1 + (Length - HeadLength) * DR + HalfHeadWidth * DC</l>
<l>ColP1 := Column1 + (Length - HeadLength) * DC - HalfHeadWidth * DR</l>
<l>RowP2 := Row1 + (Length - HeadLength) * DR - HalfHeadWidth * DC</l>
<l>ColP2 := Column1 + (Length - HeadLength) * DC + HalfHeadWidth * DR</l>
<c>* </c>
<c>* Finally create output XLD contour for each input point pair</c>
<l>for Index := 0 to |Length| - 1 by 1</l>
<l>    if (Length[Index] == -1)</l>
<c>        * Create_ single points for arrows with identical start and end point</c>
<l>        gen_contour_polygon_xld (TempArrow, Row1[Index], Column1[Index])</l>
<l>    else</l>
<c>        * Create arrow contour</c>
<l>        gen_contour_polygon_xld (TempArrow, [Row1[Index],Row2[Index],RowP1[Index],Row2[Index],RowP2[Index],Row2[Index]], [Column1[Index],Column2[Index],ColP1[Index],Column2[Index],ColP2[Index],Column2[Index]])</l>
<l>    endif</l>
<l>    concat_obj (Arrow, TempArrow, Arrow)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_contour_xld">
<abstract lang="en_US">This procedure creates arrow shaped XLD contours, which point from the coordinates (Row1, Column1) to the coordinates (Row2, Column2). The shape of the arrow head can be specified with the parameters HeadLength and HeadWidth (in pixels).

If starting and end point are identical, a contour consisting of a single point is returned.

The input tuples Row1, Column1, Row2, and Column2 have to be of the same length. HeadLength and HeadWidth either have to be of the same length as Row1, Column1, Row2, and Column2 or have to be a single element. If one of the above restrictions is violated, an error will occur.</abstract>
<alternatives>
<item>disp_arrow</item>
<item>gen_contour_polygon_xld</item>
</alternatives>
<chapters lang="de_DE">
<item>XLD</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>XLD</item>
<item>Creation</item>
</chapters>
<chapters lang="ja_JP">
<item>XLD</item>
<item>生成</item>
</chapters>
<example lang="en_US">StartPointRows:=[100,100]
StartPointColumns:=[100,100]
EndPointRows:=[200,50]
EndPointColumns:=[200,150]
dev_set_colored (3)
gen_arrow_contour_xld (Arrow, StartPointRows, StartPointColumns, EndPointRows, EndPointColumns, [10,20], [20,10])</example>
<keywords lang="de_DE">
<item>XLD-Konturen erzeugen</item>
<item>XLD-Kontur eines Pfeils erzeugen</item>
</keywords>
<keywords lang="en_US">
<item>create XLD contours</item>
<item>create XLD contour of arrow</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>gen_contour_nurbs_xld</item>
</see_also>
<short lang="en_US">Create an arrow shaped XLD contour.</short>
<successor>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Arrow">
<description lang="en_US">The generated xld</description>
<multivalue>optional</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="Column1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The column coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeadLength">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The length of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="HeadWidth">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The width of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="Row1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The row coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Row2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_names">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraType" base_type="ctrl" dimension="0"/>
<par name="ParamNames" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_names returns for each element in the camera</c>
<c>* parameter tuple that is passed in CameraParam the name</c>
<c>* of the respective camera parameter. The parameter names</c>
<c>* are returned in ParamNames. Additionally, the camera</c>
<c>* type is returned in CameraType. Alternatively, instead of</c>
<c>* the camera parameters, the camera type can be passed in</c>
<c>* CameraParam in form of one of the following strings:</c>
<c>*   - 'area_scan_division'</c>
<c>*   - 'area_scan_polynomial'</c>
<c>*   - 'area_scan_tilt_division'</c>
<c>*   - 'area_scan_tilt_polynomial'</c>
<c>*   - 'area_scan_telecentric_division'</c>
<c>*   - 'area_scan_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_division'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_division'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_polynomial'</c>
<c>*   - 'area_scan_hypercentric_division'</c>
<c>*   - 'area_scan_hypercentric_polynomial'</c>
<c>*   - 'line_scan_division'</c>
<c>*   - 'line_scan_polynomial'</c>
<c>*   - 'line_scan_telecentric_division'</c>
<c>*   - 'line_scan_telecentric_polynomial'</c>
<c>* </c>
<l>CameraParamAreaScanDivision := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricDivision := ['magnification', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTiltDivision := ['focus', 'kappa', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTiltPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltDivision := ['focus', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivision := ['magnification', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltDivision := ['magnification', 'kappa', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanHypercentricDivision := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanHypercentricPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamLinesScanDivision := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<l>CameraParamLinesScanPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<l>CameraParamLinesScanTelecentricDivision := ['magnification', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<l>CameraParamLinesScanTelecentricPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<c>* Legacy parameter names</c>
<l>CameraParamAreaScanTiltDivisionLegacy := ['focus', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTiltPolynomialLegacy := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricDivisionLegacy := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomialLegacy := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy := ['focus', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<c>* </c>
<c>* If the camera type is passed in CameraParam</c>
<l>if (|CameraParam| == 1)</l>
<l>    if (is_string(CameraParam[0]))</l>
<l>        CameraType := CameraParam[0]</l>
<l>        if (CameraType == 'area_scan_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>        elseif (CameraType == 'area_scan_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>        elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_hypercentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanHypercentricDivision]</l>
<l>        elseif (CameraType == 'area_scan_hypercentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanHypercentricPolynomial]</l>
<l>        elseif (CameraType == 'line_scan_division' or CameraType == 'line_scan')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanDivision]</l>
<l>        elseif (CameraType == 'line_scan_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanPolynomial]</l>
<l>        elseif (CameraType == 'line_scan_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanTelecentricDivision]</l>
<l>        elseif (CameraType == 'line_scan_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanTelecentricPolynomial]</l>
<l>        else</l>
<l>            throw ('Unknown camera type \'' + CameraType + '\' passed in CameraParam.')</l>
<l>        endif</l>
<l>        return ()</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* If the camera parameters are passed in CameraParam</c>
<l>if (not is_string(CameraParam[0]))</l>
<c>    * Format of camera parameters for HALCON 12 and earlier</c>
<l>    switch (|CameraParam|)</l>
<c>        * </c>
<c>        * Area Scan</c>
<l>    case 8:</l>
<c>        * CameraType: 'area_scan_division' or 'area_scan_telecentric_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanDivision</l>
<l>            CameraType := 'area_scan_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricDivisionLegacy</l>
<l>            CameraType := 'area_scan_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 10:</l>
<c>        * CameraType: 'area_scan_tilt_division' or 'area_scan_telecentric_tilt_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 12:</l>
<c>        * CameraType: 'area_scan_polynomial' or 'area_scan_telecentric_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanPolynomial</l>
<l>            CameraType := 'area_scan_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricPolynomialLegacy</l>
<l>            CameraType := 'area_scan_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 14:</l>
<c>        * CameraType: 'area_scan_tilt_polynomial' or 'area_scan_telecentric_tilt_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<c>        * </c>
<c>        * Line Scan</c>
<l>    case 11:</l>
<c>        * CameraType: 'line_scan' or 'line_scan_telecentric'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamLinesScanDivision</l>
<l>            CameraType := 'line_scan_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamLinesScanTelecentricDivision</l>
<l>            CameraType := 'line_scan_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    default:</l>
<l>        throw ('Wrong number of values in CameraParam.')</l>
<l>    endswitch</l>
<l>else</l>
<c>    * Format of camera parameters since HALCON 13</c>
<l>    CameraType := CameraParam[0]</l>
<l>    if (CameraType == 'area_scan_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>    elseif (CameraType == 'area_scan_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_hypercentric_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanHypercentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_hypercentric_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanHypercentricPolynomial]</l>
<l>    elseif (CameraType == 'line_scan_division' or CameraType == 'line_scan')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanDivision]</l>
<l>    elseif (CameraType == 'line_scan_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanPolynomial]</l>
<l>    elseif (CameraType == 'line_scan_telecentric_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'line_scan_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanTelecentricPolynomial]</l>
<l>    else</l>
<l>        throw ('Unknown camera type in CameraParam.')</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_names">
<abstract lang="en_US">&lt;proc:get_cam_par_names&gt; returns the names ParamNames of the camera parameters for each element of CameraParam. The parameter names are returned in ParamNames. Additionally, the camera type is returned in CameraType.

Alternatively, instead of the camera parameters, the camera type can be passed in CameraParam in form of one of the following strings:
   - *'area_scan_division'*
   - *'area_scan_polynomial'*
   - *'area_scan_tilt_division'*
   - *'area_scan_tilt_polynomial'*
   - *'area_scan_telecentric_division'*
   - *'area_scan_telecentric_polynomial'*
   - *'area_scan_tilt_bilateral_telecentric_division'*
   - *'area_scan_tilt_bilateral_telecentric_polynomial'*
   - *'area_scan_tilt_object_side_telecentric_division'*
   - *'area_scan_tilt_object_side_telecentric_polynomial'*
   - *'area_scan_hypercentric_division'*
   - *'area_scan_hypercentric_polynomial'*
   - *'line_scan_division'*
   - *'line_scan_polynomial'*
   - *'line_scan_telecentric_division'*
   - *'line_scan_telecentric_polynomial'*</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<chapters lang="ja_JP">
<item>キャリブレーション</item>
<item>カメラパラメーター</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_names (CameraParam, CameraType, ParamNames)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Get the names of the parameters in a camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple or camera type.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'area_scan_tilt_image_side_telecentric_division'</item>
<item>'area_scan_tilt_image_side_telecentric_polynomial'</item>
<item>'area_scan_hypercentric_division'</item>
<item>'area_scan_hypercentric_polynomial'</item>
<item>'line_scan_division'</item>
<item>'line_scan_polynomial'</item>
<item>'line_scan_telecentric_division'</item>
<item>'line_scan_telecentric_polynomial'</item>
</values>
</parameter>
<parameter id="CameraType">
<default_type>string</default_type>
<description lang="en_US">The camera type that is described by CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'line_scan_division'</item>
<item>'line_scan_polynomial'</item>
<item>'line_scan_telecentric_division'</item>
<item>'line_scan_telecentric_polynomial'</item>
</value_list>
</parameter>
<parameter id="ParamNames">
<default_type>string</default_type>
<description lang="en_US">Parameter names of the camera parameter tuple or camera type passed in CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="init_line_scan_calibration_stripe_position">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="MeasureTimeInMs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>JobPass := 0</l>
<l>global tuple GlobalNumberSubLineScanImages</l>
<l>global tuple GlobalNumCalibMarks</l>
<c>*Objektivparameter</c>
<l>FocusInMillimeter := 21.0</l>
<c>*Sensorparamter</c>
<l>SxInMicrometer := 5.86</l>
<l>SyInMicrometer := 5.86</l>
<c>*Bewegungsrichtung Einheit mm/pixel</c>
<l>Vx := 0</l>
<l>Vy := 0.347</l>
<l>Vz := 0</l>
<c>*Kameratyp</c>
<l>CameraType:='line_scan_division'</l>
<c>*Geometrie Kalibrierplatte</c>
<l>XNum := 37</l>
<l>YNum := 9</l>
<l>MarkDistInMM  := 20.0</l>
<l>DiameterRatio := 0.5</l>
<c></c>
<l>GlobalNumCalibMarks := XNum * YNum</l>
<l>GlobalNumberSubLineScanImages := 4</l>
<l>try</l>
<l>make_dir('Images')</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c>*BufferFull ist dann 1 wenn line scan buffer voll</c>
<l>BufferFull := 0</l>
<l>add_image_line_scan_buffer (Image, LineScanImages, BufferFull)</l>
<l>if(BufferFull==1)</l>
<l>    IsFullVisible := 0</l>
<c>    * Vorab prüfen ist Platte voll im Sichtfeld, erst dann exakte Bestimmung der Platte</c>
<c>    * -&gt; Reduzierung der Rechenzeit </c>
<l>    find_number_calbration_marks (LineScanImages, IsFullVisible, NumMarksScore)</l>
<l>    if(IsFullVisible)</l>
<l>        init_calibrate_camera (LineScanImages, CameraType, FocusInMillimeter, SxInMicrometer, SyInMicrometer, Vx, Vy, Vz, XNum, YNum, MarkDistInMM, DiameterRatio, JobPass, MeasureTimeInMs)</l>
<l>        if(JobPass==1)</l>
<c>          *Init ist erfolgreich durchgelaufen, dann Buffer löschen, da danach ein Jobwechsel erfolgt</c>
<l>          clear_buffer_line_scan()</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="init_line_scan_calibration_stripe_position">
<parameters>
<parameter id="Image"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="MeasureTimeInMs">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_data_COPY_1">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
<par name="ParamName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_data returns in ParamValue the value of the</c>
<c>* parameter that is given in ParamName from the tuple of</c>
<c>* camera parameters that is given in CameraParam.</c>
<c></c>
<c>* Get the parameter names that correspond to the</c>
<c>* elements in the input camera parameter tuple.</c>
<l>get_cam_par_names (CameraParam, CameraType, CameraParamNames)</l>
<c></c>
<c>* Find the index of the requested camera data and return</c>
<c>* the corresponding value.</c>
<l>ParamValue := []</l>
<l>for Index := 0 to |ParamName| - 1 by 1</l>
<l>    ParamNameInd := ParamName[Index]</l>
<l>    if (ParamNameInd == 'camera_type')</l>
<l>        ParamValue := [ParamValue,CameraType]</l>
<l>        continue</l>
<l>    endif</l>
<l>    I := find(CameraParamNames,ParamNameInd)</l>
<l>    if (I != -1)</l>
<l>        ParamValue := [ParamValue,CameraParam[I]]</l>
<l>    else</l>
<l>        throw ('Unknown camera parameter ' + ParamNameInd)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_data_COPY_1">
<abstract lang="en_US">&lt;proc:get_cam_par_data&gt; returns the value ParamValue of the camera parameter ParamName from the camera parameter tuple CameraParam. The following parameter names can be queried:
- *'camera_type'*
- *'focus'*
- *'magnification'*
- *'kappa'*
- *'k1'*
- *'k2'*
- *'k3'*
- *'p1'*
- *'p2'*
- *'image_plane_dist'*
- *'tilt'*
- *'rot'*
- *'sx'*
- *'sy'*
- *'cx'*
- *'cy'*
- *'image_width'*
- *'image_height'*
- *'vx'*
- *'vy'*
- *'vz'*.

If the camera type does not support the requested value, an exception is raised.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<chapters lang="ja_JP">
<item>キャリブレーション</item>
<item>カメラパラメーター</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_data (CameraParam, 'image_width', ImageWidth)
get_cam_par_data (CameraParam, 'image_height', ImageHeight)
gen_image_const (Image, 'byte', ImageWidth, ImageHeight)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="de_DE">Get the value of a specified camera parameter from the camera parameter tuple.</short>
<short lang="en_US">Get the value of a specified camera parameter from the camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ParamName">
<default_type>string</default_type>
<default_value>'image_width'</default_value>
<description lang="en_US">Name of the camera parameter for that the value should be returned.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'camera_type'</item>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</value_list>
</parameter>
<parameter id="ParamValue">
<default_type>real</default_type>
<description lang="en_US">Value of the requested camera parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_contour_xld_COPY_1">
<interface>
<oo>
<par name="Arrow" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="HeadLength" base_type="ctrl" dimension="0"/>
<par name="HeadWidth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure generates arrow shaped XLD contours,</c>
<c>* pointing from (Row1, Column1) to (Row2, Column2).</c>
<c>* If starting and end point are identical, a contour consisting</c>
<c>* of a single point is returned.</c>
<c></c>
<c>* input parameters:</c>
<c>* Row1, Column1: Coordinates of the arrows' starting points</c>
<c>* Row2, Column2: Coordinates of the arrows' end points</c>
<c>* HeadLength, HeadWidth: Size of the arrow heads in pixels</c>
<c></c>
<c>* output parameter:</c>
<c>* Arrow: The resulting XLD contour</c>
<c></c>
<c>* The input tuples Row1, Column1, Row2, and Column2 have to be of</c>
<c>* the same length.</c>
<c>* HeadLength and HeadWidth either have to be of the same length as</c>
<c>* Row1, Column1, Row2, and Column2 or have to be a single element.</c>
<c>* If one of the above restrictions is violated, an error will occur.</c>
<c></c>
<c></c>
<c>* Initialization.</c>
<l>gen_empty_obj (Arrow)</l>
<c></c>
<c>* Calculate the arrow length</c>
<l>distance_pp (Row1, Column1, Row2, Column2, Length)</l>
<c></c>
<c>* Mark arrows with identical start and end point</c>
<c>* (set Length to -1 to avoid division-by-zero exception)</c>
<l>ZeroLengthIndices := find(Length,0)</l>
<l>if (ZeroLengthIndices != -1)</l>
<l>    Length[ZeroLengthIndices] := -1</l>
<l>endif</l>
<c></c>
<c>* Calculate auxiliary variables.</c>
<l>DR := 1.0 * (Row2 - Row1) / Length</l>
<l>DC := 1.0 * (Column2 - Column1) / Length</l>
<l>HalfHeadWidth := HeadWidth / 2.0</l>
<c></c>
<c>* Calculate end points of the arrow head.</c>
<l>RowP1 := Row1 + (Length - HeadLength) * DR + HalfHeadWidth * DC</l>
<l>ColP1 := Column1 + (Length - HeadLength) * DC - HalfHeadWidth * DR</l>
<l>RowP2 := Row1 + (Length - HeadLength) * DR - HalfHeadWidth * DC</l>
<l>ColP2 := Column1 + (Length - HeadLength) * DC + HalfHeadWidth * DR</l>
<c></c>
<c>* Finally create output XLD contour for each input point pair</c>
<l>for Index := 0 to |Length| - 1 by 1</l>
<l>    if (Length[Index] == -1)</l>
<c>        * Create_ single points for arrows with identical start and end point</c>
<l>        gen_contour_polygon_xld (TempArrow, Row1[Index], Column1[Index])</l>
<l>    else</l>
<c>        * Create arrow contour</c>
<l>        gen_contour_polygon_xld (TempArrow, [Row1[Index],Row2[Index],RowP1[Index],Row2[Index],RowP2[Index],Row2[Index]], [Column1[Index],Column2[Index],ColP1[Index],Column2[Index],ColP2[Index],Column2[Index]])</l>
<l>    endif</l>
<l>    concat_obj (Arrow, TempArrow, Arrow)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_contour_xld_COPY_1">
<abstract lang="en_US">This procedure creates arrow shaped XLD contours, which point from the coordinates (Row1, Column1) to the coordinates (Row2, Column2). The shape of the arrow head can be specified with the parameters HeadLength and HeadWidth (in pixels).

If starting and end point are identical, a contour consisting of a single point is returned.

The input tuples Row1, Column1, Row2, and Column2 have to be of the same length. HeadLength and HeadWidth either have to be of the same length as Row1, Column1, Row2, and Column2 or have to be a single element. If one of the above restrictions is violated, an error will occur.</abstract>
<alternatives>
<item>disp_arrow</item>
<item>gen_contour_polygon_xld</item>
</alternatives>
<chapters lang="de_DE">
<item>XLD</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>XLD</item>
<item>Creation</item>
</chapters>
<chapters lang="ja_JP">
<item>XLD</item>
<item>生成</item>
</chapters>
<example lang="en_US">StartPointRows:=[100,100]
StartPointColumns:=[100,100]
EndPointRows:=[200,50]
EndPointColumns:=[200,150]
dev_set_colored (3)
gen_arrow_contour_xld (Arrow, StartPointRows, StartPointColumns, EndPointRows, EndPointColumns, [10,20], [20,10])</example>
<keywords lang="de_DE">
<item>XLD-Konturen erzeugen</item>
<item>XLD-Kontur eines Pfeils erzeugen</item>
</keywords>
<keywords lang="en_US">
<item>create XLD contours</item>
<item>create XLD contour of arrow</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>gen_contour_nurbs_xld</item>
</see_also>
<short lang="de_DE">Create an arrow shaped XLD contour.</short>
<short lang="en_US">Create an arrow shaped XLD contour.</short>
<successor>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Arrow">
<description lang="en_US">The generated xld</description>
<multivalue>optional</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="Column1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The column coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeadLength">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The length of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="HeadWidth">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The width of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="Row1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The row coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Row2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="save_line_scan_camera_parameter_stripe_position">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>JobPass := 0</l>
<c></c>
<l>FileNameInternalCamParameter:='StripePosition'+'InternalCameraParameter.dat'</l>
<l>FileNameExternalCamParameter:='StripePosition'+'ExternalCameraParameter.dat'</l>
<l>save_intern_camera_parameter (Image, FileNameInternalCamParameter, FileNameExternalCamParameter, JobPass)</l>
<l>return ()</l>
</body>
<docu id="save_line_scan_camera_parameter_stripe_position">
<parameters>
<parameter id="Image"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
<value_min>0</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_line_scan_calibration_images">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="MarksDiameterScore" base_type="ctrl" dimension="0"/>
<par name="OverexposureScore" base_type="ctrl" dimension="0"/>
<par name="ContrastScore" base_type="ctrl" dimension="0"/>
<par name="HomogeneityScore" base_type="ctrl" dimension="0"/>
<par name="FocusScore" base_type="ctrl" dimension="0"/>
<par name="NumImagesScore" base_type="ctrl" dimension="0"/>
<par name="TiltScore" base_type="ctrl" dimension="0"/>
<par name="FieldOfViewScore" base_type="ctrl" dimension="0"/>
<par name="MeanSquareError" base_type="ctrl" dimension="0"/>
<par name="CurrentImages" base_type="ctrl" dimension="0"/>
<par name="MeasureTimeInMs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>JobPass := 0</l>
<l>BufferFull := 0</l>
<c>*JobPass ist eins wenn Buffer voll</c>
<l>add_image_line_scan_buffer (Image, LineScanImages, BufferFull)</l>
<l>if(BufferFull==1)</l>
<l>    WarningThresholdInPercent := 50.0</l>
<l>    NoImageTest := 1</l>
<l>    NoSequenceTest := 1</l>
<l>    IsFullVisible := 0</l>
<c>    *Vorab prüfen ist Platte voll im Sichtfeld, erst dann exakte Bestimmung der Platte</c>
<c>    *Reduzierung der Rechenzeit </c>
<l>    find_number_calbration_marks (LineScanImages, IsFullVisible, NumMarksScore)</l>
<l>    if(IsFullVisible==1)</l>
<l>        evaluate_calibration_images (LineScanImages, WarningThresholdInPercent, NoImageTest, NoSequenceTest, JobPass, MarksDiameterScore, OverexposureScore, ContrastScore, HomogeneityScore, FocusScore, NumImagesScore, TiltScore, FieldOfViewScore, MeanSquareError, CurrentImages, MeasureTimInms)</l>
<l>        if(JobPass==1) </l>
<c>            *Die Suche nach der Platte ist rechenintensiv, Buffer Löschen da während der Suchzeit neue Blöcke von der Kamera aufgenommen wurden</c>
<l>            clear_buffer_line_scan()</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
<c></c>
</body>
<docu id="evaluate_line_scan_calibration_images">
<parameters>
<parameter id="ContrastScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="CurrentImages">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="FieldOfViewScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="FocusScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="HomogeneityScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="Image"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="MarksDiameterScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="MeanSquareError">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="MeasureTimeInMs">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="NumImagesScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="OverexposureScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="TiltScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="init_calibrate_camera">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CameraType" base_type="ctrl" dimension="0"/>
<par name="FocusInMillimeter" base_type="ctrl" dimension="0"/>
<par name="SxInMicrometer" base_type="ctrl" dimension="0"/>
<par name="SyInMicrometer" base_type="ctrl" dimension="0"/>
<par name="VxInMMPerPixel" base_type="ctrl" dimension="0"/>
<par name="VyInMMPerPixel" base_type="ctrl" dimension="0"/>
<par name="VzinMMPerPixel" base_type="ctrl" dimension="0"/>
<par name="XNum" base_type="ctrl" dimension="0"/>
<par name="YNum" base_type="ctrl" dimension="0"/>
<par name="MarkDistInMM" base_type="ctrl" dimension="0"/>
<par name="DiameterRatio" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="MeasureTime" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_image_size (InputImage, ImageWidth, ImageHeight)</l>
<l>JobPass := 0</l>
<l>global tuple GlobalCalibDataID</l>
<l>global tuple GlobalImageIndexCameraCalibration</l>
<l>global tuple GlobalObservPoses</l>
<l>global tuple GlobalObservPointsColumns</l>
<l>global tuple GlobalObservPointsRows</l>
<l>global tuple GlobalOptimalBlackWhiteRatio</l>
<l>global tuple GlobalDescriptionFileName</l>
<l>global tuple GlobalNumCalibMarks</l>
<c>*Umrechnung von mü nach Meter</c>
<l>SxInMeter := SxInMicrometer/1000000.0</l>
<l>SyInMeter := SyInMicrometer/1000000.0</l>
<c>*Umrechnung von mm nach Meter</c>
<l>FocusInMeter := FocusInMillimeter/1000.0</l>
<c></c>
<l>if(CameraType == 'line_scan_division')</l>
<c>    *Umrechnung in Meter pro Pixel</c>
<l>    Vx := VxInMMPerPixel/1000.0</l>
<l>    Vy := VyInMMPerPixel/1000.0</l>
<l>    Vz := VzinMMPerPixel/1000.0</l>
<l>    StartCameraParameter := ['line_scan_division',FocusInMeter,0,SxInMeter,SyInMeter,ImageWidth/2,ImageHeight/2,ImageWidth,ImageHeight,Vx,Vy,Vz]</l>
<l>else</l>
<l>    StartCameraParameter := ['area_scan_division',FocusInMeter,0,SxInMeter,SyInMeter,ImageWidth/2,ImageHeight/2,ImageWidth,ImageHeight]</l>
<l>endif</l>
<c></c>
<l>try</l>
<l>clear_calib_data (GlobalCalibDataID)</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c>*Erzeugung der Kalibrierplate</c>
<l>gen_calibration_plate (XNum, YNum, MarkDistInMM, DiameterRatio, 'CalibrationPlate')</l>
<l>GlobalNumCalibMarks := YNum * XNum</l>
<l>MarkDiameterInMM := MarkDistInMM * DiameterRatio</l>
<l>MeasureMarksArea := (MarkDistInMM * (XNum-1) + MarkDiameterInMM) * (MarkDistInMM * (YNum-1) + MarkDiameterInMM)</l>
<l>AreaMeasureMarks := (MarkDiameterInMM/2) * (MarkDiameterInMM/2) * 3.14159 * GlobalNumCalibMarks</l>
<l>AreaWithouMeasureMarks := MeasureMarksArea - AreaMeasureMarks</l>
<c>*Referenzwert für die spätere Bestimmung des Schwarz-Weiß-Verhältnis der Kalibriermarken</c>
<l>GlobalOptimalBlackWhiteRatio := real(AreaWithouMeasureMarks)/MeasureMarksArea</l>
<c>*Kalibrierobjekt anlegen und Startparameter übergeben</c>
<l>try</l>
<l>create_calib_data ('calibration_object', 1, 1, GlobalCalibDataID)</l>
<l>set_calib_data_cam_param (GlobalCalibDataID, 0, [], StartCameraParameter)</l>
<l>set_calib_data_calib_object (GlobalCalibDataID, 0, GlobalDescriptionFileName)</l>
<l>catch (Exception)</l>
<l>     throw('Error init_calibrate_camera. Can Not Create Calibration Object:' + GlobalDescriptionFileName)</l>
<l>     return()</l>
<l>endtry</l>
<c>*Suche Kalibrierplatte </c>
<l>GlobalImageIndexCameraCalibration := 0</l>
<l>GlobalObservPoses := []</l>
<l>GlobalObservPointsColumns := []</l>
<l>GlobalObservPointsRows := []</l>
<l>evaluate_calibration_images (InputImage, 50.0, 1, 1, JobPass, MarksDiameterScore, OverexposureScore, ContrastScore, HomogeneityScore, FocusScore, NumImageScore, TiltScore, FielOfViewScore, MeanSquareError, CurrentImages, MeasureTime)</l>
<l>if(JobPass==1)</l>
<c>   *Platte gefunden dann ok, Sequenz dann bei Null starten init dient nur zur Kontrolle ob Eingangsparameter alle ok</c>
<l>   GlobalImageIndexCameraCalibration := 0</l>
<l>   GlobalObservPoses := []</l>
<l>   GlobalObservPointsColumns := []</l>
<l>   GlobalObservPointsRows := []</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="init_calibrate_camera">
<chapters lang="en_US">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<library lang="en_US">Bertram Standard Procedures</library>
<parameters>
<parameter id="CameraType">
<default_type>string</default_type>
<default_value>line_scan_division</default_value>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DiameterRatio">
<default_type>real</default_type>
<default_value>0.5</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="FocusInMillimeter">
<default_type>real</default_type>
<default_value>20.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="InputImage"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="MarkDistInMM">
<default_type>real</default_type>
<default_value>20.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="MeasureTime">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="SxInMicrometer">
<default_type>real</default_type>
<default_value>5.86</default_value>
<description lang="de_DE">Einheit ist µm</description>
<mixed_type>false</mixed_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="SyInMicrometer">
<default_type>real</default_type>
<default_value>5.86</default_value>
<description lang="de_DE">Einheit ist µm</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="VxInMMPerPixel">
<default_type>real</default_type>
<default_value>0.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="VyInMMPerPixel">
<default_type>real</default_type>
<default_value>0.295</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="VzinMMPerPixel">
<default_type>real</default_type>
<default_value>0.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="XNum">
<default_type>integer</default_type>
<default_value>9</default_value>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="YNum">
<default_type>integer</default_type>
<default_value>9</default_value>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_calibration_images">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WarningThresholdInPercent" base_type="ctrl" dimension="0"/>
<par name="NoImageTest" base_type="ctrl" dimension="0"/>
<par name="NoSequenceTest" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="MarksDiameterScore" base_type="ctrl" dimension="0"/>
<par name="OverexposureScore" base_type="ctrl" dimension="0"/>
<par name="ContrastScore" base_type="ctrl" dimension="0"/>
<par name="HomogeneityScore" base_type="ctrl" dimension="0"/>
<par name="FocusScore" base_type="ctrl" dimension="0"/>
<par name="NumImagesScore" base_type="ctrl" dimension="0"/>
<par name="TiltScore" base_type="ctrl" dimension="0"/>
<par name="FieldOfViewScore" base_type="ctrl" dimension="0"/>
<par name="MeanSquareError" base_type="ctrl" dimension="0"/>
<par name="CurrentImages" base_type="ctrl" dimension="0"/>
<par name="MeasureTimeInMs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>JobPass := 0</l>
<l>global tuple GlobalCalibDataID</l>
<l>global tuple GlobalImageIndexCameraCalibration</l>
<c></c>
<l>global tuple GlobalObservPointsRows</l>
<l>global tuple GlobalObservPointsColumns</l>
<l>global tuple GlobalObservPoses</l>
<c></c>
<l>global tuple GlobalFieldOfViewScore</l>
<l>global tuple GlobalNumImagesScore</l>
<c></c>
<l>ErrorImageDir:='Images/ErrorImagePool'</l>
<c>*Wenn GlobalImageIndexCameraCalibration == 0 dann allererster Aufruf. Fehlerbildspeicher Löschen</c>
<l>if(GlobalImageIndexCameraCalibration == 0)</l>
<l>    clear_and_make_image_dir(ErrorImageDir)</l>
<l>endif</l>
<c>*Messzeiten aufnehmen</c>
<l>count_seconds(StartCountSecond)</l>
<l>try</l>
<l>    get_image_size (InputImage, ImageWidth, ImageHeight)</l>
<l>    GenParamName:=['sigma','alpha','gap_tolerance','max_diam_marks','skip_find_caltab']</l>
<l>    GenParamValue:=[1.0, 1.5,1.0,300,'false']</l>
<l>    find_calib_object (InputImage, GlobalCalibDataID, 0, 0, GlobalImageIndexCameraCalibration, GenParamName, GenParamValue)</l>
<l>    get_calib_data(GlobalCalibDataID, 'camera',0, 'init_params',StartCamerParam)</l>
<c>    * Get observed marks.</c>
<l>    get_calib_data_observ_contours (CalibPlateMarks, GlobalCalibDataID, 'marks', 0, 0, GlobalImageIndexCameraCalibration)</l>
<l>    count_obj(CalibPlateMarks,NumberCalibPlateMarks)</l>
<l>    if(NumberCalibPlateMarks&gt;0)</l>
<l>        get_calib_data_observ_contours (Pattern, GlobalCalibDataID, 'caltab',0,0,GlobalImageIndexCameraCalibration)</l>
<l>        gen_region_contour_xld (CalibPlateMarks, Region, 'filled')</l>
<l>        union1 (Region, RegionUnion)</l>
<l>        shape_trans (RegionUnion, RegionCalibPlate, 'convex')</l>
<c>        * Diameter &gt; 20 ==&gt; Score = 1.0  Diameter &lt; 15 Score = 0</c>
<l>        evaluate_caltab_image_marks_diameter (CalibPlateMarks, MarksDiameter, _MarksDiameterScore)</l>
<l>        MarksDiameterScore:=_MarksDiameterScore * 100.0</l>
<c>        * Max Overexposure:</c>
<l>        evaluate_caltab_image_overexposure (InputImage, RegionCalibPlate, _OverexposureScore)</l>
<l>        OverexposureScore:=_OverexposureScore*100.0</l>
<c>        * Contrast and Homogeneity:</c>
<l>        evaluate_caltab_image_contrast_homogeneity (InputImage, CalibPlateMarks, Contrast, _ContrastScore, _HomogeneityScore)</l>
<l>        ContrastScore:=_ContrastScore * 100.0</l>
<l>        HomogeneityScore:=_HomogeneityScore * 100.0</l>
<c>        * Focus:</c>
<l>        evaluate_caltab_image_focus (InputImage, CalibPlateMarks, Contrast, _FocusScore)</l>
<l>        FocusScore:=_FocusScore * 100.0</l>
<c>        * Evaluate number of images:</c>
<l>        evaluate_caltab_sequence_number_images (2, GlobalImageIndexCameraCalibration, _NumImagesScore)</l>
<l>        NumImagesScore:=_NumImagesScore * 100.0</l>
<l>        GlobalNumImagesScore := NumImagesScore</l>
<c>        * Concatenate coordinates of marks.</c>
<l>        get_calib_data_observ_points (GlobalCalibDataID, 0, 0, GlobalImageIndexCameraCalibration, Row, Column, Index, Pose)</l>
<c>        * Get region of calibration plate.</c>
<l>        GlobalObservPointsRows := [GlobalObservPointsRows,Row]</l>
<l>        GlobalObservPointsColumns := [GlobalObservPointsColumns,Column]</l>
<l>        GlobalObservPoses := [GlobalObservPoses,Pose]</l>
<c>        * Update the distribution of the marks and the amount of tilt achieved with the current sequence of images.</c>
<c>        * Tilt angles:</c>
<l>        evaluate_caltab_sequence_tilt (GlobalObservPoses, _TiltScore)</l>
<l>        TiltScore:=_TiltScore * 100.0</l>
<c>        * Distribution:</c>
<l>        evaluate_caltab_sequence_field_of_view_coverage (DistanceImage, GlobalObservPointsRows, GlobalObservPointsColumns, ImageWidth, ImageHeight, MarksDiameter, _FieldOfViewScore)</l>
<l>        FieldOfViewScore := _FieldOfViewScore * 100.0</l>
<l>        GlobalFieldOfViewScore := FieldOfViewScore</l>
<c>        * Define display colors and threshold, when a score shall be displayed colored as not ok.</c>
<c>        * Score results: determine display colors.</c>
<l>        ColorResOK := 'blue'</l>
<l>        ColorResNOK := 'red'</l>
<l>        Text := 'Quality Scores Single Image:' </l>
<l>        Text[|Text|] := 'Diameter of Marks: ' + MarksDiameterScore$'.f'+'%'+ ' (' + MarksDiameter$'.1f' + ' px)'</l>
<l>        Text[|Text|] := 'Exposure: ' +  OverexposureScore$'.f'+'%'</l>
<l>        Text[|Text|] := 'Homogeneity: ' + HomogeneityScore$'.f'+'%'</l>
<l>        Text[|Text|] := 'Contrast: ' + ContrastScore$'.2f'+'%'</l>
<l>        Text[|Text|] := 'Focus: '+ FocusScore$'.2f'+'%'</l>
<l>        Text[|Text|] := ' \n'</l>
<l>        Text[|Text|] := 'Quality Scores: Whole Sequence:'</l>
<l>        Text[|Text|] := 'Score Number of Images: ' + NumImagesScore$'.f'+'%'</l>
<l>        Text[|Text|] := 'Field of View: ' + FieldOfViewScore$'.f'+'%'</l>
<l>        Text[|Text|] := 'Tilt Angles: ' + TiltScore$'.f'+'%'</l>
<l>        Text[|Text|] := ' \n'</l>
<l>        Text[|Text|] := 'Current Pose Data:'</l>
<l>        Text[|Text|] := 'X: ' + Pose[0]$'.2f'</l>
<l>        Text[|Text|] := 'Y: ' + Pose[1]$'.2f'</l>
<l>        Text[|Text|] := 'Z: ' + Pose[2]$'.2f'</l>
<l>        Text[|Text|] := 'alpha: ' + Pose[3]$'.2f'</l>
<l>        Text[|Text|] := 'beta:  ' + Pose[4]$'.2f'</l>
<l>        Text[|Text|] := 'gamma: ' + Pose[5]$'.2f'</l>
<l>        Text[|Text|] := ' \n'</l>
<l>        ColorRes := gen_tuple_const(|Text|,ColorResOK)</l>
<l>        IsImageQualityGood:=1</l>
<l>        if(NoImageTest==0)</l>
<l>            if (MarksDiameterScore &lt;= WarningThresholdInPercent)</l>
<l>                ColorRes[1] := ColorResNOK</l>
<l>                IsImageQualityGood:=0</l>
<l>            endif</l>
<l>            if (OverexposureScore &lt;= WarningThresholdInPercent)</l>
<l>                ColorRes[2] := ColorResNOK</l>
<l>                IsImageQualityGood:=0</l>
<l>            endif</l>
<l>            if (HomogeneityScore &lt;= WarningThresholdInPercent)</l>
<l>                ColorRes[3] := ColorResNOK</l>
<l>                IsImageQualityGood:=0</l>
<l>            endif</l>
<l>            if (ContrastScore &lt;= WarningThresholdInPercent)</l>
<l>                ColorRes[4] := ColorResNOK</l>
<l>                IsImageQualityGood:=0</l>
<l>            endif</l>
<l>            if (FocusScore &lt;= WarningThresholdInPercent)</l>
<l>                ColorRes[5] := ColorResNOK</l>
<l>                IsImageQualityGood:=0</l>
<l>            endif</l>
<l>        endif</l>
<l>        IsImageSequenceGood:=1</l>
<l>        if(NoSequenceTest==0 and IsImageQualityGood==1)</l>
<l>            if (NumImagesScore &lt;= WarningThresholdInPercent)</l>
<l>                ColorRes[7] := ColorResNOK</l>
<l>                IsImageSequenceGood:=0</l>
<l>            endif</l>
<l>            if (FieldOfViewScore &lt;= WarningThresholdInPercent)</l>
<l>                ColorRes[8] := ColorResNOK</l>
<l>                IsImageSequenceGood:=0</l>
<l>            endif</l>
<l>            if (TiltScore &lt;= WarningThresholdInPercent)</l>
<l>                ColorRes[9] := ColorResNOK</l>
<l>                IsImageSequenceGood:=0</l>
<l>            endif</l>
<l>        endif</l>
<l>        if(IsImageQualityGood==1)</l>
<l>          GlobalImageIndexCameraCalibration := GlobalImageIndexCameraCalibration + 1</l>
<l>          if(IsImageSequenceGood==1)</l>
<l>              JobPass:=1</l>
<l>          endif</l>
<l>        endif</l>
<l>        dev_clear_window()</l>
<l>        dev_display (InputImage)</l>
<l>        dev_set_line_width(2)</l>
<l>        dev_set_color ('green')</l>
<l>        dev_display (CalibPlateMarks)</l>
<l>        dev_display (Pattern)</l>
<l>        dev_set_colored (3)</l>
<l>        dev_disp_3d_coord_system(StartCamerParam, Pose, 1e-2)</l>
<l>        RowTextPosStart:=0</l>
<l>        ColumnTextPosStart:=0</l>
<l>        if(JobPass==1)</l>
<l>            MeanSquareError:=0</l>
<l>            calibrate_cameras (GlobalCalibDataID, MeanSquareError)</l>
<c>            *Anzahl erfolgreich aufgenommenen Bilder</c>
<l>            CurrentImages:=GlobalImageIndexCameraCalibration</l>
<c>            * Bild und Daten speichern, dient nur zur Kontrolle  </c>
<l>            ImageDir:='Images/RecordingCalibrationData'</l>
<l>            if(GlobalImageIndexCameraCalibration == 1)</l>
<l>              clear_and_make_image_dir(ImageDir)</l>
<l>            endif</l>
<l>            FileName:=ImageDir + '/CalibImage' + GlobalImageIndexCameraCalibration$'02' </l>
<l>            write_image (InputImage, 'bmp', 0, FileName)</l>
<l>            Text[|Text|] := 'Mean Square Error: ' + MeanSquareError$'.3f' + ' px'</l>
<l>            ColorRes[|Text|-1]:= ColorResOK</l>
<l>            FileName:=ImageDir + '/Results' + GlobalImageIndexCameraCalibration$'02'+ '.txt'</l>
<l>            open_file (FileName, 'output', FileHandle)</l>
<l>            for Index := 0 to |Text|-1 by 1</l>
<l>               fwrite_string (FileHandle,Text[Index] +'\n')</l>
<l>            endfor</l>
<l>            close_file (FileHandle)</l>
<l>        endif</l>
<l>        draw_text_message_BDevEngine (Text, ColorRes, RowTextPosStart, ColumnTextPosStart)</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>    dev_get_exception_data(Exception, 'error_message',ErrorMsg)</l>
<l>    dev_get_exception_data(Exception,'error_code',ErrorCode)</l>
<c>    * Code 8432 und 8404 bedeuten Kalibrierplatte nich gefunden oder nicht vollständig im Sichtfeld</c>
<c>    * Fehlerbild speichern </c>
<l>    get_system_time (MSecond, Second, Minute, Hour, Day, YDay, Month, Year)</l>
<l>    DateString := Year$'4d' + '_' + Month$'02d' + '_' + Day$'02d'</l>
<l>    TimeString := Hour$'02d' + '_' + Minute$'02d' + '_' + Second$'02d' + '_' + MSecond$'02d'</l>
<l>    FileNameErrorImages := ErrorImageDir + '/ErrorImage' + DateString + '_' + TimeString</l>
<l>    write_image (InputImage, 'bmp', 0, FileNameErrorImages)</l>
<l>    if(ErrorCode != 8432 and ErrorCode != 8404)</l>
<l>         count_seconds(EndCountSecond)</l>
<l>         MeasureTimeInMs:=(EndCountSecond-StartCountSecond)*1000.0</l>
<l>         throw ('Error evaluate calibration images. ' + ErrorMsg)</l>
<l>    endif</l>
<l>endtry</l>
<l>count_seconds(EndCountSecond)</l>
<l>MeasureTimeInMs:=(EndCountSecond-StartCountSecond)*1000.0</l>
<c>*Hier globale Variabeln um die Werte in der BDevEngine immer wieder anzuzeigen</c>
<l>if(JobPass==0)</l>
<l>     try</l>
<l>     FieldOfViewScore:=GlobalFieldOfViewScore</l>
<l>     catch(Exception)</l>
<l>      GlobalFieldOfViewScore:=0.0</l>
<l>     endtry</l>
<l>     try</l>
<l>     NumImagesScore := GlobalNumImagesScore</l>
<l>     catch(Exception)</l>
<l>      GlobalNumImagesScore:=0.0</l>
<l>     endtry</l>
<l>     try</l>
<l>     CurrentImages:=GlobalImageIndexCameraCalibration</l>
<l>     catch(Exseption)</l>
<l>      CurrentImages:=0 </l>
<l>     endtry</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="evaluate_calibration_images">
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<library lang="de_DE">Bertram Standard Procedures</library>
<parameters>
<parameter id="ContrastScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="CurrentImages">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="FieldOfViewScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="FocusScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="HomogeneityScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="InputImage"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="MarksDiameterScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="MeanSquareError">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="MeasureTimeInMs">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="NoImageTest">
<default_type>integer</default_type>
<default_value>1</default_value>
<type_list>
<item>integer</item>
</type_list>
<value_max>10</value_max>
<value_min>0</value_min>
</parameter>
<parameter id="NoSequenceTest">
<default_type>integer</default_type>
<default_value>1</default_value>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
<value_min>0</value_min>
</parameter>
<parameter id="NumImagesScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="OverexposureScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="TiltScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
</parameter>
<parameter id="WarningThresholdInPercent">
<default_type>real</default_type>
<default_value>60.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="save_intern_camera_parameter">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="InternalCameraParameterFile" base_type="ctrl" dimension="0"/>
<par name="ExternalCameraParameterFile" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>global tuple GlobalCalibDataID</l>
<l>global tuple GlobalExternCameraParameter</l>
<l>global tuple GlobalInternCameraParameter</l>
<l>global tuple GlobalImageIndexCameraCalibration</l>
<c></c>
<l>JobPass := 0</l>
<l>ReferencPoseIndex := 0</l>
<l>try</l>
<l>    if (GlobalImageIndexCameraCalibration &lt; 6)</l>
<l>      throw ([32000,'Nicht genügend Kalibriebilder aufgenommen'])</l>
<l>      return ()</l>
<l>    endif</l>
<l>*     set_calib_data (GlobalCalibDataID, 'camera', 'general', 'excluded_settings', 'focus')</l>
<l>*     set_calib_data (GlobalCalibDataID, 'camera', 'general', 'excluded_settings', ['cx','cy'])</l>
<l>*     set_calib_data (GlobalCalibDataID, 'camera', 'general', 'excluded_settings', ['sx','sy'])</l>
<l>    Error := 0</l>
<l>    calibrate_cameras (GlobalCalibDataID, Error)</l>
<l>    get_calib_data (GlobalCalibDataID, 'camera', 0, 'params', CamParam)</l>
<c>    *Alte Datei löschen</c>
<l>    try</l>
<l>    delete_file(InternalCameraParameterFile)</l>
<l>    catch(Excption)</l>
<l>    endtry</l>
<c>    *Interne Kameraparamter abspeichern</c>
<l>    write_cam_par (CamParam, InternalCameraParameterFile)</l>
<l>    get_calib_data (GlobalCalibDataID, 'camera', 0, 'params_labels', ParLabels)</l>
<c>    * Display results</c>
<l>    if (|ParLabels| == 12)</l>
<l>        Units := ['', 'm', '', 'm', 'm', 'px', 'px', 'px', 'px','m/px','m/px','m/px']</l>
<l>    else</l>
<l>        Units := ['', 'm', '', 'm', 'm', 'px', 'px', 'px', 'px']</l>
<l>    endif</l>
<l>    FormatStringFileName := max(strlen(InternalCameraParameterFile))$'0' + 's'</l>
<l>    FormatStringLabels := max(strlen(ParLabels))$'0' + 's'</l>
<l>    CamParTable := ParLabels$FormatStringLabels + ' = ' + CamParam + ' ' + Units</l>
<l>    get_calib_data (GlobalCalibDataID, 'calib_obj_pose', [0,ReferencPoseIndex], 'pose', Pose)</l>
<c>    *Alte Datei löschen</c>
<l>    try</l>
<l>    delete_file(ExternalCameraParameterFile)</l>
<l>    catch(Excption)</l>
<l>    endtry</l>
<l>    write_pose(Pose,ExternalCameraParameterFile)</l>
<l>    clear_calib_data (GlobalCalibDataID)</l>
<l>    Message := ['Camera is calibrated and saved into:',InternalCameraParameterFile$FormatStringFileName,' ',CamParTable,' ','Mean Square Error = ' + Error$'.3f' + ' px']</l>
<l>    ColorRes := gen_tuple_const(|Message|,'blue')</l>
<c>    *Einmal alle Kalibrierdaten sichern, nur für Debug</c>
<l>    FileName:=InternalCameraParameterFile+'FullResults.txt'</l>
<l>    open_file (FileName, 'output', FileHandle)</l>
<l>    for Index := 0 to |Message|-1 by 1</l>
<l>       fwrite_string (FileHandle,Message[Index] +'\n')</l>
<l>    endfor</l>
<l>    close_file (FileHandle)</l>
<c>    *Anzeige der Ergebnisse in das Bild</c>
<l>    RowTextPosStart := 0</l>
<l>    ColumnTextPosStart := 0</l>
<l>    draw_text_message_BDevEngine (Message, ColorRes, RowTextPosStart, ColumnTextPosStart)</l>
<l>    JobPass := 1</l>
<c>    *Erzwingt hier später ein Neuladen der Kameraparameter wenn das Messprogramm aufgerufen wird</c>
<l>    GlobalExternCameraParameter := []</l>
<l>    GlobalInternCameraParameter := []</l>
<l>catch (Exception)</l>
<l>    dev_get_exception_data(Exception, 'error_message',ErrorMsg)</l>
<l>    dev_get_exception_data(Exception,'error_code',ErrorCode)</l>
<l>    dev_get_exception_data(Exception, 'user_data',UserError)</l>
<c>    *Error Code from write_cam_par</c>
<l>    throw ('Can Not Save/Calibrate Calibration Object. '+ ErrorMsg +' ' + UserError )</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="save_intern_camera_parameter">
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<library lang="de_DE">Bertram Standard Procedures</library>
<parameters>
<parameter id="ExternalCameraParameterFile">
<default_type>string</default_type>
<default_value>ExternalCameraParameter.dat</default_value>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="InputImage"/>
<parameter id="InternalCameraParameterFile">
<default_type>string</default_type>
<default_value>InternalCameraParameter.dat</default_value>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="draw_text_message_BDevEngine">
<interface>
<ic>
<par name="Message" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="RowTextPosStart" base_type="ctrl" dimension="0"/>
<par name="ColumnTextPosStart" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>MaxLenght:=0</l>
<l>TextHeight:=15</l>
<l>TextWidth:=TextHeight/2.0</l>
<l>for i := 0 to |Message| - 1 by 1</l>
<l>        Length := strlen(Message[i])</l>
<l>        if(Length&gt;MaxLenght)</l>
<l>          MaxLenght:=Length</l>
<l>        endif</l>
<l>endfor</l>
<l>gen_rectangle1(BackGroundTextRectangle,RowTextPosStart,ColumnTextPosStart,RowTextPosStart+(|Message|*TextHeight),ColumnTextPosStart+(MaxLenght*TextWidth))</l>
<l>dev_set_color('#fce9d4')</l>
<l>dev_set_draw ('fill')</l>
<l>dev_display (BackGroundTextRectangle)</l>
<l>for i := 0 to |Message| - 1 by 1</l>
<c>        </c>
<l>        dev_disp_text (Message[i], 'image', RowTextPosStart, ColumnTextPosStart, Color[i],'box',false)</l>
<l>        RowTextPosStart := RowTextPosStart + TextHeight</l>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="draw_text_message_BDevEngine">
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<mixed_type>optional</mixed_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ColumnTextPosStart">
<default_type>integer</default_type>
<default_value>0</default_value>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Message">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="RowTextPosStart">
<default_type>integer</default_type>
<default_value>0</default_value>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_caltab_image_marks_diameter">
<interface>
<io>
<par name="Marks" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="MarksDiameter" base_type="ctrl" dimension="0"/>
<par name="MakrsDiameterScore" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure calculates</c>
<c>* the mean diameter of the calibration marks.</c>
<c></c>
<l>MarksDiameter := 0.0</l>
<l>MarksDiameterScore := 0.0</l>
<l>count_obj (Marks, Number)</l>
<l>if (Number &lt; 4)</l>
<l>    return ()</l>
<l>endif</l>
<l>gen_region_contour_xld (Marks, Region, 'filled')</l>
<l>diameter_region (Region, Row11, Column11, Row2, Column2, MarksDiameter)</l>
<l>MarksDiameter := mean(MarksDiameter)</l>
<l>DiameterScoreFull := 20</l>
<l>DiameterScoreZero := 15</l>
<l>MakrsDiameterScore := max2(min2(MarksDiameter,DiameterScoreFull) - DiameterScoreZero,0) * 1.0 / (DiameterScoreFull - DiameterScoreZero)</l>
<l>return ()</l>
</body>
<docu id="evaluate_caltab_image_marks_diameter">
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<library lang="de_DE">Bertram Internal Procedures</library>
<parameters>
<parameter id="MakrsDiameterScore"/>
<parameter id="Marks">
<multivalue>true</multivalue>
<sem_type>xld</sem_type>
</parameter>
<parameter id="MarksDiameter">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_caltab_image_overexposure">
<interface>
<io>
<par name="ImageCalibPlate" base_type="iconic" dimension="0"/>
<par name="RegionCalibPlate" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="OverexposureScore" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure returns a measure</c>
<c>* of the amount of overexposure</c>
<c>* in the calibration plate image.</c>
<l>global tuple GlobalOptimalBlackWhiteRatio</l>
<l>MinRatio:=GlobalOptimalBlackWhiteRatio *0.4</l>
<l>MaxRatio:=1.0</l>
<c></c>
<l>OverexposureScore := 0.0</l>
<l>area_center (RegionCalibPlate, AreaCalibPlate, Row, Column)</l>
<l>if (AreaCalibPlate == 0 or AreaCalibPlate == [])</l>
<l>    return ()</l>
<l>endif</l>
<l>reduce_domain (ImageCalibPlate, RegionCalibPlate, ImageReduced)</l>
<c>* If the gray value is 255,</c>
<c>* we interpret this as overexposure.</c>
<l>threshold (ImageReduced, Region, 240, 255)</l>
<l>area_center (Region, AreaOverexp, Row, Column)</l>
<l>Ratio := real(AreaOverexp) / AreaCalibPlate</l>
<l>*Ratio := 1.0 - Ratio</l>
<l>*MaxRatio := 0.15</l>
<c></c>
<l>* if (Ratio &lt; MaxRatio)</l>
<c>    * This score indicates the amount of overexposure</c>
<c>    * compared to the maximum tolerated overexposure.</c>
<l>*     OverexposureScore := min([1.0,1 - Ratio / MaxRatio])</l>
<l>* endif</l>
<c></c>
<l>if(Ratio&gt;GlobalOptimalBlackWhiteRatio)</l>
<l>    OverexposureScore := (Ratio - MaxRatio)/(GlobalOptimalBlackWhiteRatio - MaxRatio)</l>
<l>    OverexposureScore := min([OverexposureScore,1.0])</l>
<l>else</l>
<l>    OverexposureScore := (Ratio - MinRatio)/(GlobalOptimalBlackWhiteRatio - MinRatio)</l>
<l>    OverexposureScore := max([OverexposureScore,0])</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="evaluate_caltab_image_overexposure">
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<library lang="de_DE">Bertram Internal Procedures</library>
<parameters>
<parameter id="ImageCalibPlate">
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="OverexposureScore">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RegionCalibPlate">
<multivalue>false</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_caltab_image_contrast_homogeneity">
<interface>
<io>
<par name="ImageCalibPlate" base_type="iconic" dimension="0"/>
<par name="CalibPlateMarks" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="ContrastScore" base_type="ctrl" dimension="0"/>
<par name="HomogeneityScore" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>ContrastScore := 0.0</l>
<l>Contrast := 0.0</l>
<l>HomogeneityScore := 0.0</l>
<l>count_obj (CalibPlateMarks, Number)</l>
<l>if (Number &lt; 4)</l>
<l>    return ()</l>
<l>endif</l>
<c>* Calculate contrast.</c>
<l>gen_region_contour_xld (CalibPlateMarks, Region, 'margin')</l>
<l>dilation_circle (Region, RegionDilation, 5.5)</l>
<l>min_max_gray (RegionDilation, ImageCalibPlate, 3, Min, Max, Range)</l>
<l>Contrast := mean(Range)</l>
<c>* Calculate contrast score.</c>
<c>* Indicates the average contrast of the calibration mark</c>
<l>MinContrast := 70.0</l>
<l>SufficientContrast := 100.0</l>
<l>if (Contrast &gt; MinContrast)</l>
<l>    ContrastScore := (Contrast - MinContrast) / (SufficientContrast - MinContrast)</l>
<l>    ContrastScore := min([ContrastScore,1.0])</l>
<l>endif</l>
<c>* Calculate homogeneity score.</c>
<c>* Indicates the homogeneity of the calibration marks</c>
<c>* concerning their brightness.</c>
<l>HomogeneityScore := 1.1 - (deviation(Max) / 40.0)</l>
<l>HomogeneityScore := max([min([HomogeneityScore,1.0]),0.0])</l>
<l>return ()</l>
</body>
<docu id="evaluate_caltab_image_contrast_homogeneity">
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<library lang="de_DE">Bertram Standard Procedures</library>
<parameters>
<parameter id="CalibPlateMarks">
<multivalue>true</multivalue>
<sem_type>xld</sem_type>
</parameter>
<parameter id="Contrast">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ContrastScore">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="HomogeneityScore">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageCalibPlate">
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_caltab_image_focus">
<interface>
<io>
<par name="ImageCalibPlate" base_type="iconic" dimension="0"/>
<par name="CalibPlateMarks" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Contrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FocusScore" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure compares</c>
<c>* the contrast of the markers boundary</c>
<c>* (= MeanGradient)</c>
<c>* with the contrast values found</c>
<c>* around the boundary (= Contrast).</c>
<c></c>
<l>FocusScore := 0.0</l>
<l>if (Contrast == 0)</l>
<l>    return ()</l>
<l>endif</l>
<l>count_obj (CalibPlateMarks, Number)</l>
<l>if (Number &lt; 4)</l>
<l>    return ()</l>
<l>endif</l>
<l>gen_region_contour_xld (CalibPlateMarks, Region, 'margin')</l>
<l>union1 (Region, RegionUnion)</l>
<l>reduce_domain (ImageCalibPlate, RegionUnion, ImageReduced)</l>
<l>derivate_gauss (ImageReduced, DerivGauss, 0.7, 'gradient')</l>
<l>intensity (Region, DerivGauss, MeanGradient, Deviation)</l>
<l>MinScore := 0.25</l>
<c>* Normalize the gradient with the contrast.</c>
<l>RawResult := MeanGradient / Contrast</l>
<c></c>
<c>* Select a value representing a non-extreme case.</c>
<l>FocusScore := sort(RawResult * 4.5)[round(|RawResult| / 20.0)]</l>
<l>FocusScore := min([max([FocusScore - MinScore,0.0]),1.0])</l>
<l>return ()</l>
</body>
<docu id="evaluate_caltab_image_focus">
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<library lang="de_DE">Bertram Internal Procedures</library>
<parameters>
<parameter id="CalibPlateMarks">
<multivalue>true</multivalue>
<sem_type>xld</sem_type>
</parameter>
<parameter id="Contrast">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="FocusScore"/>
<parameter id="ImageCalibPlate">
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_caltab_sequence_number_images">
<interface>
<ic>
<par name="PlateDescriptionVersion" base_type="ctrl" dimension="0"/>
<par name="NumImages" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="NumImagesScore" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure evaluates the number of</c>
<c>* images used for the calibration process.</c>
<c></c>
<c>* The recommended number of images depends on the used calibration plate.</c>
<l>NumImagesScore := 0.0</l>
<l>if (PlateDescriptionVersion &gt; 2)</l>
<l>    MinRecommendedImages := 6</l>
<l>    NumImagesScore := min2(real(NumImages) / real(MinRecommendedImages),1)</l>
<l>else</l>
<l>    if (NumImages &lt; 6)</l>
<l>        NumImagesScore := 0.0</l>
<l>    else</l>
<l>        NumImagesScore := min2(0.1 * (NumImages - 5.0),1)</l>
<l>    endif</l>
<l>endif</l>
<c>* In this case the plate has enough readable marks:</c>
<c>* Increase the number of used images.</c>
<l>return ()</l>
</body>
<docu id="evaluate_caltab_sequence_number_images">
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<library lang="de_DE">Bertram Standard Procedures</library>
<parameters>
<parameter id="NumImages"/>
<parameter id="NumImagesScore"/>
<parameter id="PlateDescriptionVersion"/>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_caltab_sequence_tilt">
<interface>
<ic>
<par name="ObservPoses" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TiltScore" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure indicates whether the calibration plates</c>
<c>* have been tilted sufficiently in both directions.</c>
<c></c>
<c>* Remove identical poses.</c>
<l>NrPoses := |ObservPoses| / 7</l>
<c>* Find duplicates.</c>
<l>PoseIsDupl := gen_tuple_const(NrPoses,0)</l>
<l>if (NrPoses &gt; 1)</l>
<l>    for IndPose1 := 0 to NrPoses - 2 by 1</l>
<l>        if (PoseIsDupl[IndPose1])</l>
<l>            continue</l>
<l>        endif</l>
<l>        Pose1 := ObservPoses[IndPose1 * 7:(IndPose1 + 1) * 7 - 1]</l>
<l>        for IndPose2 := IndPose1 + 1 to NrPoses - 1 by 1</l>
<l>            Pose2 := ObservPoses[IndPose2 * 7:(IndPose2 + 1) * 7 - 1]</l>
<l>            if (Pose1 == Pose2)</l>
<l>                PoseIsDupl[IndPose2] := 1</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<l>endif</l>
<c>* Take Slant and Pan (Indices 4 and 5 of the poses) of unique poses.</c>
<c>* Bring the values into the interval (-180, 180].</c>
<l>Slant := []</l>
<l>Pan := []</l>
<l>for IndPose := 0 to NrPoses - 1 by 1</l>
<l>    if (not PoseIsDupl[IndPose])</l>
<l>        SlantPose := ObservPoses[7 * IndPose + 3]</l>
<l>        if (SlantPose &gt; 180)</l>
<l>            SlantPose := 360 - SlantPose</l>
<l>        endif</l>
<l>        Slant := [Slant,SlantPose]</l>
<l>        PanPose := ObservPoses[7 * IndPose + 4]</l>
<l>        if (PanPose &gt; 180)</l>
<l>            PanPose := 360 - PanPose</l>
<l>        endif</l>
<l>        Pan := [Pan,PanPose]</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c>* Make sure, |angles| &gt; 75 deg will result in a score of 0 and shift the optimal angle.</c>
<l>SlantFunctVal := min2(abs(Slant),75)</l>
<l>SlantFunctVal := SlantFunctVal * 90.0 / 75.0</l>
<l>PanFunctVal := min2(abs(Pan),75)</l>
<l>PanFunctVal := PanFunctVal * 90.0 / 75.0</l>
<c></c>
<c>* Optimal angle: 37.5 deg, tilt angles within [29,46] deg result in &gt; 0.9 with a plateau for the max score.</c>
<c>* Sort the scores in decreasing order in order to pick the highest values easily.</c>
<l>PanScores := 1 - abs(pow(cos(rad(PanFunctVal * 2)),2))</l>
<l>PanScores := min2(PanScores * 1.05,1.0)</l>
<l>PanScores := inverse(sort(PanScores))</l>
<l>SlantScores := 1 - abs(pow(cos(rad(SlantFunctVal * 2)),2))</l>
<l>SlantScores := min2(SlantScores * 1.05,1.0)</l>
<l>SlantScores := inverse(sort(SlantScores))</l>
<c>* At least 4 images are used to get the full score (we recommend to have 4 tilted images).</c>
<l>MinNumImFullScore := 4</l>
<l>NumImUsedForScore := min([MinNumImFullScore,|SlantScores|])</l>
<l>SlantScore := sum(SlantScores[0:NumImUsedForScore - 1]) / MinNumImFullScore</l>
<l>PanScore := sum(PanScores[0:NumImUsedForScore - 1]) / MinNumImFullScore</l>
<c></c>
<c>* The final score is simply the mean of both angle scores.</c>
<l>TiltScore := (PanScore + SlantScore) * 0.5</l>
<l>return ()</l>
</body>
<docu id="evaluate_caltab_sequence_tilt">
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<library lang="de_DE">Bertram Standard Procedures</library>
<parameters>
<parameter id="ObservPoses"/>
<parameter id="TiltScore"/>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_caltab_sequence_field_of_view_coverage">
<interface>
<oo>
<par name="DistanceImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ObservPointsRows" base_type="ctrl" dimension="0"/>
<par name="ObservPointsColumns" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="MarksDiameter" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FieldOfViewScore" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure gives an indication whether the</c>
<c>* calibration marks cover the whole field of view.</c>
<c></c>
<l>gen_region_points (Region, ObservPointsRows, ObservPointsColumns)</l>
<l>ImageWidth := max([ImageWidth,ObservPointsColumns])</l>
<l>ImageHeight := max([ImageHeight,ObservPointsRows])</l>
<l>distance_transform (Region, DistanceImage, 'octagonal', 'false', ImageWidth, ImageHeight)</l>
<c>* A clipping is needed because the marks cannot come close to the border.</c>
<l>Border := max([ImageWidth,ImageHeight]) / 15</l>
<l>gen_rectangle1 (Mask, Border, Border, ImageHeight - 1 - Border, ImageWidth - 1 - Border)</l>
<c>* Max gray value corresponds to the furthest distance to a mark.</c>
<l>min_max_gray (Mask, DistanceImage, 0, Min, Max, Range)</l>
<c>* Calculate the diagonal as maximal distance.</c>
<l>distance_pp (0, 0, ImageHeight - 1, ImageWidth - 1, ImageDiagonal)</l>
<c></c>
<l>MinThresh := 0.3</l>
<l>MaxThresh := 0.85</l>
<l>Ratio := Max / ImageDiagonal * 2.5</l>
<l>Tmp1 := 1 - Ratio</l>
<l>Tmp2 := (Tmp1 - MinThresh) / (MaxThresh - MinThresh)</l>
<l>FieldOfViewScore := max([min([Tmp2,1.0]),0.0])</l>
<c></c>
<c>* Compute a distance image that is suitable for visualization.</c>
<l>dilation_circle (Region, RegionDilation, MarksDiameter * 1.25)</l>
<l>distance_transform (RegionDilation, DistanceImage, 'octagonal', 'false', ImageWidth, ImageHeight)</l>
<l>return ()</l>
</body>
<docu id="evaluate_caltab_sequence_field_of_view_coverage">
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<library lang="de_DE">Bertram Standard Procedures</library>
<parameters>
<parameter id="DistanceImage"/>
<parameter id="FieldOfViewScore">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth"/>
<parameter id="MarksDiameter">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObservPointsColumns"/>
<parameter id="ObservPointsRows"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_3d_coord_system">
<interface>
<ic>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
<par name="CoordAxesLength" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays a 3D coordinate system.</c>
<c>* It needs the procedure gen_arrow_contour_xld.</c>
<c></c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window where the coordinate system shall be displayed</c>
<c>* CamParam: The camera parameters</c>
<c>* Pose: The pose to be displayed</c>
<c>* CoordAxesLength: The length of the coordinate axes in world coordinates</c>
<c></c>
<c>* Check, if Pose is a correct pose tuple.</c>
<l>if (|Pose| != 7)</l>
<l>    return ()</l>
<l>endif</l>
<l>get_cam_par_data (CamParam, 'camera_type', CameraType)</l>
<l>IsTelecentric := strstr(CameraType,'telecentric') != -1</l>
<l>if (Pose[2] == 0.0 and not IsTelecentric)</l>
<c>    * For projective cameras:</c>
<c>    * Poses with Z position zero cannot be projected</c>
<c>    * (that would lead to a division by zero error).</c>
<l>    return ()</l>
<l>endif</l>
<c>* Convert to pose to a transformation matrix</c>
<l>pose_to_hom_mat3d (Pose, TransWorld2Cam)</l>
<c>* Project the world origin into the image</c>
<l>affine_trans_point_3d (TransWorld2Cam, 0, 0, 0, OrigCamX, OrigCamY, OrigCamZ)</l>
<l>project_3d_point (OrigCamX, OrigCamY, OrigCamZ, CamParam, Row0, Column0)</l>
<c>* Project the coordinate axes into the image</c>
<l>affine_trans_point_3d (TransWorld2Cam, CoordAxesLength, 0, 0, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxX, ColumnAxX)</l>
<l>affine_trans_point_3d (TransWorld2Cam, 0, CoordAxesLength, 0, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxY, ColumnAxY)</l>
<l>affine_trans_point_3d (TransWorld2Cam, 0, 0, CoordAxesLength, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxZ, ColumnAxZ)</l>
<c></c>
<c>* Generate an XLD contour for each axis</c>
<l>distance_pp ([Row0,Row0,Row0], [Column0,Column0,Column0], [RowAxX,RowAxY,RowAxZ], [ColumnAxX,ColumnAxY,ColumnAxZ], Distance)</l>
<l>HeadLength := int(max([max(Distance) / 12.0,5.0]))</l>
<l>gen_arrow_contour_xld (Arrows, [Row0,Row0,Row0], [Column0,Column0,Column0], [RowAxX,RowAxY,RowAxZ], [ColumnAxX,ColumnAxY,ColumnAxZ], HeadLength, HeadLength)</l>
<c></c>
<l>dev_display (Arrows)</l>
<l>dev_disp_text ('X', 'image', RowAxX + 3, ColumnAxX + 3, 'red', 'box', 'false')</l>
<l>dev_disp_text ('Y', 'image', RowAxY + 3, ColumnAxY + 3, 'green', 'box', 'false')</l>
<l>dev_disp_text ('Z', 'image', RowAxZ + 3, ColumnAxZ + 3, 'blue', 'box', 'false')</l>
<l>return ()</l>
</body>
<docu id="dev_disp_3d_coord_system">
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Matching-3D</item>
</chapters>
<library lang="de_DE">Bertram Internal Procedures</library>
<short lang="en_US">Display the axes of a 3d coordinate system</short>
<parameters>
<parameter id="CamParam"/>
<parameter id="CoordAxesLength"/>
<parameter id="Pose"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_calibration_plate">
<interface>
<ic>
<par name="XNum" base_type="ctrl" dimension="0"/>
<par name="YNum" base_type="ctrl" dimension="0"/>
<par name="MarkDistInMM" base_type="ctrl" dimension="0"/>
<par name="DiameterRatio" base_type="ctrl" dimension="0"/>
<par name="FileName" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>global tuple GlobalDescriptionFileName</l>
<l>CalibFileExtension:='.descr'</l>
<c></c>
<l>GlobalDescriptionFileName := FileName + CalibFileExtension</l>
<l>PostScriptFileName  := FileName + '.ps'</l>
<c></c>
<l>MarkDistInMeter := MarkDistInMM/1000.0</l>
<l>if(CalibFileExtension == '.descr')</l>
<l>  gen_caltab (XNum, YNum, MarkDistInMeter, DiameterRatio, GlobalDescriptionFileName, PostScriptFileName)</l>
<l>else</l>
<l>  DiameterInMeter := MarkDistInMeter * DiameterRatio  </l>
<l>  MarkPosRow := (YNum-1)/2</l>
<l>  MarkPosCol := (XNum-1)/2</l>
<l>  create_caltab (YNum, XNum, DiameterInMeter, MarkPosRow, MarkPosCol, 'dark_on_light', GlobalDescriptionFileName, PostScriptFileName)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="gen_calibration_plate">
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<library lang="de_DE">Bertram Internal Procedures</library>
<parameters>
<parameter id="DiameterRatio">
<default_type>real</default_type>
<default_value>0.5</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="FileName">
<default_type>string</default_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="MarkDistInMM">
<default_type>real</default_type>
<default_value>20.0</default_value>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="XNum">
<default_type>integer</default_type>
<default_value>9</default_value>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="YNum">
<default_type>integer</default_type>
<default_value>9</default_value>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_names_COPY_1">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraType" base_type="ctrl" dimension="0"/>
<par name="ParamNames" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_names returns for each element in the camera</c>
<c>* parameter tuple that is passed in CameraParam the name</c>
<c>* of the respective camera parameter. The parameter names</c>
<c>* are returned in ParamNames. Additionally, the camera</c>
<c>* type is returned in CameraType. Alternatively, instead of</c>
<c>* the camera parameters, the camera type can be passed in</c>
<c>* CameraParam in form of one of the following strings:</c>
<c>*   - 'area_scan_division'</c>
<c>*   - 'area_scan_polynomial'</c>
<c>*   - 'area_scan_tilt_division'</c>
<c>*   - 'area_scan_tilt_polynomial'</c>
<c>*   - 'area_scan_telecentric_division'</c>
<c>*   - 'area_scan_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_division'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_division'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_polynomial'</c>
<c>*   - 'area_scan_hypercentric_division'</c>
<c>*   - 'area_scan_hypercentric_polynomial'</c>
<c>*   - 'line_scan_division'</c>
<c>*   - 'line_scan_polynomial'</c>
<c>*   - 'line_scan_telecentric_division'</c>
<c>*   - 'line_scan_telecentric_polynomial'</c>
<c></c>
<l>CameraParamAreaScanDivision := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricDivision := ['magnification', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTiltDivision := ['focus', 'kappa', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTiltPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltDivision := ['focus', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivision := ['magnification', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltDivision := ['magnification', 'kappa', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanHypercentricDivision := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanHypercentricPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamLinesScanDivision := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<l>CameraParamLinesScanPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<l>CameraParamLinesScanTelecentricDivision := ['magnification', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<l>CameraParamLinesScanTelecentricPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<c>* Legacy parameter names</c>
<l>CameraParamAreaScanTiltDivisionLegacy := ['focus', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTiltPolynomialLegacy := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricDivisionLegacy := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomialLegacy := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy := ['focus', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<c></c>
<c>* If the camera type is passed in CameraParam</c>
<l>if (|CameraParam| == 1)</l>
<l>    if (is_string(CameraParam[0]))</l>
<l>        CameraType := CameraParam[0]</l>
<l>        if (CameraType == 'area_scan_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>        elseif (CameraType == 'area_scan_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>        elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_hypercentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanHypercentricDivision]</l>
<l>        elseif (CameraType == 'area_scan_hypercentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanHypercentricPolynomial]</l>
<l>        elseif (CameraType == 'line_scan_division' or CameraType == 'line_scan')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanDivision]</l>
<l>        elseif (CameraType == 'line_scan_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanPolynomial]</l>
<l>        elseif (CameraType == 'line_scan_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanTelecentricDivision]</l>
<l>        elseif (CameraType == 'line_scan_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanTelecentricPolynomial]</l>
<l>        else</l>
<l>            throw ('Unknown camera type \'' + CameraType + '\' passed in CameraParam.')</l>
<l>        endif</l>
<l>        return ()</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>* If the camera parameters are passed in CameraParam</c>
<l>if (not is_string(CameraParam[0]))</l>
<c>    * Format of camera parameters for HALCON 12 and earlier</c>
<l>    switch (|CameraParam|)</l>
<c></c>
<c>        * Area Scan</c>
<l>    case 8:</l>
<c>        * CameraType: 'area_scan_division' or 'area_scan_telecentric_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanDivision</l>
<l>            CameraType := 'area_scan_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricDivisionLegacy</l>
<l>            CameraType := 'area_scan_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 10:</l>
<c>        * CameraType: 'area_scan_tilt_division' or 'area_scan_telecentric_tilt_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 12:</l>
<c>        * CameraType: 'area_scan_polynomial' or 'area_scan_telecentric_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanPolynomial</l>
<l>            CameraType := 'area_scan_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricPolynomialLegacy</l>
<l>            CameraType := 'area_scan_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 14:</l>
<c>        * CameraType: 'area_scan_tilt_polynomial' or 'area_scan_telecentric_tilt_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<c></c>
<c>        * Line Scan</c>
<l>    case 11:</l>
<c>        * CameraType: 'line_scan' or 'line_scan_telecentric'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamLinesScanDivision</l>
<l>            CameraType := 'line_scan_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamLinesScanTelecentricDivision</l>
<l>            CameraType := 'line_scan_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    default:</l>
<l>        throw ('Wrong number of values in CameraParam.')</l>
<l>    endswitch</l>
<l>else</l>
<c>    * Format of camera parameters since HALCON 13</c>
<l>    CameraType := CameraParam[0]</l>
<l>    if (CameraType == 'area_scan_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>    elseif (CameraType == 'area_scan_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_hypercentric_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanHypercentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_hypercentric_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanHypercentricPolynomial]</l>
<l>    elseif (CameraType == 'line_scan_division' or CameraType == 'line_scan')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanDivision]</l>
<l>    elseif (CameraType == 'line_scan_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanPolynomial]</l>
<l>    elseif (CameraType == 'line_scan_telecentric_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'line_scan_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanTelecentricPolynomial]</l>
<l>    else</l>
<l>        throw ('Unknown camera type in CameraParam.')</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_names_COPY_1">
<abstract lang="en_US">&lt;proc:get_cam_par_names&gt; returns the names ParamNames of the camera parameters for each element of CameraParam. The parameter names are returned in ParamNames. Additionally, the camera type is returned in CameraType.

Alternatively, instead of the camera parameters, the camera type can be passed in CameraParam in form of one of the following strings:
   - *'area_scan_division'*
   - *'area_scan_polynomial'*
   - *'area_scan_tilt_division'*
   - *'area_scan_tilt_polynomial'*
   - *'area_scan_telecentric_division'*
   - *'area_scan_telecentric_polynomial'*
   - *'area_scan_tilt_bilateral_telecentric_division'*
   - *'area_scan_tilt_bilateral_telecentric_polynomial'*
   - *'area_scan_tilt_object_side_telecentric_division'*
   - *'area_scan_tilt_object_side_telecentric_polynomial'*
   - *'area_scan_hypercentric_division'*
   - *'area_scan_hypercentric_polynomial'*
   - *'line_scan_division'*
   - *'line_scan_polynomial'*
   - *'line_scan_telecentric_division'*
   - *'line_scan_telecentric_polynomial'*</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<chapters lang="ja_JP">
<item>キャリブレーション</item>
<item>カメラパラメーター</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_names (CameraParam, CameraType, ParamNames)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="de_DE">Get the names of the parameters in a camera parameter tuple.</short>
<short lang="en_US">Get the names of the parameters in a camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple or camera type.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'area_scan_tilt_image_side_telecentric_division'</item>
<item>'area_scan_tilt_image_side_telecentric_polynomial'</item>
<item>'area_scan_hypercentric_division'</item>
<item>'area_scan_hypercentric_polynomial'</item>
<item>'line_scan_division'</item>
<item>'line_scan_polynomial'</item>
<item>'line_scan_telecentric_division'</item>
<item>'line_scan_telecentric_polynomial'</item>
</values>
</parameter>
<parameter id="CameraType">
<default_type>string</default_type>
<description lang="en_US">The camera type that is described by CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'line_scan_division'</item>
<item>'line_scan_polynomial'</item>
<item>'line_scan_telecentric_division'</item>
<item>'line_scan_telecentric_polynomial'</item>
</value_list>
</parameter>
<parameter id="ParamNames">
<default_type>string</default_type>
<description lang="en_US">Parameter names of the camera parameter tuple or camera type passed in CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="find_data_matrix">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="SymbolType" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="ResultCode" base_type="ctrl" dimension="0"/>
<par name="CodeXPos" base_type="ctrl" dimension="0"/>
<par name="CodeYPos" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="CellDefects" base_type="ctrl" dimension="0"/>
<par name="ContrastSNR" base_type="ctrl" dimension="0"/>
<par name="PatternDefects" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>JobPass := 0</l>
<l>ResultCode := ''</l>
<l>NumberOccurences := 1</l>
<l>CodeXPos := 0</l>
<l>CodeYpos := 0</l>
<l>Contrast := -1</l>
<l>CellDefects := -1</l>
<l>ContrastSNR := -1</l>
<l>PatternDefects := -1</l>
<c>* Constants for quality value access</c>
<c>* The values correspond to the position of the elements in the tuple</c>
<l>CONTRAST := 10</l>
<l>CONTRAST_SNR := 11</l>
<l>CELL_DEFECTS := 18</l>
<l>FP_DEFECTS := 19</l>
<c>* find code</c>
<l>create_data_code_2d_model (SymbolType, 'default_parameters', 'maximum_recognition', DataCodeHandleStandard)</l>
<l>find_data_code_2d (Image, SymbolXLDs, DataCodeHandleStandard, 'stop_after_result_num', NumberOccurences, ResultHandles, DecodedDataStrings)</l>
<c>* visualize</c>
<l>dev_set_color ('yellow')</l>
<l>dev_set_draw('margin')</l>
<l>dev_set_line_width(6)</l>
<l>dev_display (SymbolXLDs)</l>
<c>* result ouput</c>
<l>if (|ResultHandles| == 1) </l>
<l>    select_obj (SymbolXLDs, SymbolXLD, 1)</l>
<l>    get_contour_xld (SymbolXLD, Row, Col)</l>
<l>    ResultCode := DecodedDataStrings</l>
<c>    </c>
<l>    CodeXSize := max(Col) - min(Col)</l>
<l>    CodeYSize := max(Row) - min(Row)</l>
<c>    *Code center position</c>
<l>    CodeXpos := min(Col) + CodeXSize/2</l>
<l>    CodeYpos := min(Row) + CodeYSize/2</l>
<c>        </c>
<l>    get_data_code_2d_results (DataCodeHandleStandard, ResultHandles, 'quality_semi_t10_values', QualityValues)</l>
<l>    get_data_code_2d_results (DataCodeHandleStandard, 'general', 'quality_semi_t10_labels', Labels)</l>
<c>    </c>
<l>    if(QualityValues[CONTRAST]!='N/A')</l>
<l>      Contrast:=QualityValues[CONTRAST]</l>
<l>      *Message := Labels[CONTRAST] + ':  ' + QualityValues[CONTRAST]$'.2f' + '%'</l>
<l>    endif</l>
<l>    if(QualityValues[CELL_DEFECTS]!='N/A')</l>
<l>      CellDefects:=QualityValues[CELL_DEFECTS]</l>
<l>      *Message[|Message|] := Labels[CELL_DEFECTS] + ':  ' + QualityValues[CELL_DEFECTS]$'.2f' + '%'</l>
<l>    endif</l>
<l>    if(QualityValues[CONTRAST_SNR]!='N/A')</l>
<l>      ContrastSNR:=QualityValues[CONTRAST_SNR]</l>
<l>      *Message[|Message|] := Labels[CONTRAST_SNR] + ':  ' + QualityValues[CONTRAST_SNR]$'.2f' + '%'</l>
<l>    endif</l>
<l>    if(QualityValues[FP_DEFECTS]!='N/A')</l>
<l>      PatternDefects:=QualityValues[FP_DEFECTS]</l>
<l>      *Message[|Message|] := Labels[FP_DEFECTS]   + ':  ' + QualityValues[FP_DEFECTS]$'.2f' + '%'</l>
<l>    endif</l>
<l>    *ColorRes := gen_tuple_const(|Message|,'blue')</l>
<l>    *draw_text_message_BDevEngine (Message, ColorRes, min(Row), max(Col))</l>
<l>    JobPass := 1</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="find_data_matrix">
<parameters>
<parameter id="CellDefects">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="CodeXPos">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="CodeYPos">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Contrast">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ContrastSNR">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
<value_min>0</value_min>
</parameter>
<parameter id="PatternDefects">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ResultCode">
<default_type>string</default_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="SymbolType">
<default_type>string</default_type>
<default_value>Data Matrix ECC 200</default_value>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="init_line_scan_calibration_DMC">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="MeasureTimeInMs" base_type="ctrl" dimension="0"/>
<par name="DebugText" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>JobPass := 0</l>
<c>*Objektivparameter</c>
<l>FocusInMillimeter := 21.0</l>
<c>*Sensorparamter</c>
<l>SxInMicrometer := 5.86</l>
<l>SyInMicrometer := 5.86</l>
<c>*Bewegungsrichtung Einheit mm/pixel</c>
<l>Vx := 0</l>
<l>Vy := 0.071</l>
<l>Vz := 0</l>
<c>*Kamera type</c>
<l>CameraType:='line_scan_division'</l>
<c>*Geometrie Kalibrierplatte</c>
<l>XNum := 9</l>
<l>YNum := 9</l>
<l>MarkDistInMM  := 20.0</l>
<l>DiameterRatio := 0.5</l>
<l>NumberLineScanImages := 1</l>
<l>init_calibrate_camera (Image, CameraType, FocusInMillimeter, SxInMicrometer, SyInMicrometer, Vx, Vy, Vz, XNum, YNum, MarkDistInMM, DiameterRatio, JobPass, MeasureTimeInMs)</l>
<l>return ()</l>
</body>
<docu id="init_line_scan_calibration_DMC">
<parameters>
<parameter id="DebugText">
<default_type>string</default_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Image"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="MeasureTimeInMs">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="save_line_scan_camera_parameter_DMC">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>JobPass:=0</l>
<l>FileNameInternalCamParameter:='DMC'+'InternalCameraParameter.dat'</l>
<l>FileNameExternalCamParameter:='DMC'+'ExternalCameraParameter.dat'</l>
<l>save_intern_camera_parameter (Image, FileNameInternalCamParameter, FileNameExternalCamParameter, JobPass)</l>
<l>return ()</l>
</body>
<docu id="save_line_scan_camera_parameter_DMC">
<parameters>
<parameter id="Image"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
<value_min>0</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_line_size_in_millimeter_DMC">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="LineSizeInMillimeter" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>JobPass := 0</l>
<l>SubName:='DMC'</l>
<l>FileNameInternCamPar:=SubName+'InternalCameraParameter.dat'</l>
<l>try</l>
<l>    read_cam_par(FileNameInternCamPar,InternCamerParameter)</l>
<l>    LineSizeInMillimeter := InternCamerParameter[10]*1000.0</l>
<l>    JobPass:=1</l>
<l>catch(Exception)</l>
<c>    *hier noch keine Kalibrierdaten vorhanden oder Kalibrierung nicht zwingend erforderlich, Rückgabe Startwert</c>
<l>    JobPass:=1</l>
<l>    FileNameInternCamPar := SubName + 'StartParamterCalibration.tup'</l>
<l>    try</l>
<l>     read_tuple(FileNameInternCamPar,StartParamter)</l>
<l>     LineSizeInMillimeter:=StartParamter[0]</l>
<l>    catch(Exception)</l>
<c>        *Datei für Startwerte noch nicht vorhanden erzeuge dann eine Defaultdatei</c>
<l>     LineSizeInMillimeter := 0.071</l>
<l>     write_tuple(LineSizeInMillimeter,FileNameInternCamPar)</l>
<l>    endtry</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="get_line_size_in_millimeter_DMC">
<parameters>
<parameter id="Image"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="LineSizeInMillimeter">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="find_number_calbration_marks">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="FullVisible" base_type="ctrl" dimension="0"/>
<par name="NumMarksScore" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>FullVisible := 0</l>
<l>global tuple GlobalNumCalibMarks</l>
<c></c>
<l>try</l>
<l>NumberMarks := GlobalNumCalibMarks</l>
<l>catch(Exception)</l>
<l>return()</l>
<l>endtry</l>
<l>NumMarksScore := 0.0</l>
<l>BinThreshold:=100</l>
<l>ThresholdOffset := 20</l>
<l>NumberRuns := 5</l>
<l>StartThreshold := BinThreshold + (ThresholdOffset * (NumberRuns/2))</l>
<l>for Index := 0 to (NumberRuns-1) by 1</l>
<l>    threshold (InputImage, Region, 0,StartThreshold)</l>
<l>    connection (Region, ConnectedRegions)</l>
<c>    *Auswahl nur Kreisförmige Objekte</c>
<l>    select_shape (ConnectedRegions, RoundCandidates, 'circularity', 'and', 0.6, 1)</l>
<c>    *Auswahl nur Kreise mit einem Bestimmten Durchmessser</c>
<l>    select_shape (RoundCandidates, Candidates, 'max_diameter', 'and', 10.0, 300.0)</l>
<l>    count_obj(Candidates,NumMatchResult)</l>
<l>    if (NumMatchResult == GlobalNumCalibMarks)</l>
<l>        FullVisible := 1</l>
<l>        NumMarksScore := 100.0</l>
<l>        break</l>
<l>    else</l>
<l>        StartThreshold := StartThreshold - ThresholdOffset</l>
<l>        NumMarksScore := (real(NumMatchResult)/GlobalNumCalibMarks) * 100.0</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>* if(NumMatchResult&gt;0)</l>
<l>*      FileName:='ErrorLogCalibration' + '.txt'</l>
<l>*      open_file (FileName, 'append', FileHandle)</l>
<l>*      fwrite_string (FileHandle,DebugText +'\n')</l>
<l>*      close_file (FileHandle)</l>
<l>* endif</l>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="find_number_calbration_marks">
<parameters>
<parameter id="FullVisible">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
<value_min>0</value_min>
</parameter>
<parameter id="InputImage"/>
<parameter id="NumMarksScore">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="find_data_matrix_line_scan">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="SymbolType" base_type="ctrl" dimension="0"/>
<par name="RoiOffsetInMM" base_type="ctrl" dimension="0"/>
<par name="RoiWidthInMM" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="JobPass" base_type="ctrl" dimension="0"/>
<par name="ResultCode" base_type="ctrl" dimension="0"/>
<par name="CodeXPosInMM" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="CellDefects" base_type="ctrl" dimension="0"/>
<par name="ContrastSNR" base_type="ctrl" dimension="0"/>
<par name="PatternDefects" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>JobPass := 0</l>
<l>ResultCode := ''</l>
<c></c>
<l>get_image_size (Image, Width, Height)</l>
<l>get_line_size_in_millimeter_DMC(Image,JobPass,PixelSize)</l>
<c></c>
<l>RoiOffsetInPixel := RoiOffsetInMM/PixelSize</l>
<l>RoiWidthInPixel := RoiWidthInMM/PixelSize</l>
<l>if((RoiOffsetInPixel + RoiWidthInPixel) &gt; (Width-1))</l>
<l>    RoiOffsetInPixel := 0</l>
<l>    RoiWidthInPixel := Width-1</l>
<l>endif</l>
<c></c>
<l>gen_rectangle1(RoiRectangle,0, RoiOffsetInPixel, Height-1, RoiOffsetInPixel + RoiWidthInPixel)</l>
<l>reduce_domain(Image, RoiRectangle, RoiImage)</l>
<c></c>
<l>dev_set_part(0, RoiOffsetInPixel, Height-1, RoiOffsetInPixel + RoiWidthInPixel)</l>
<c></c>
<l>dev_set_color('yellow')</l>
<l>dev_set_draw('margin')</l>
<l>dev_set_line_width(6)</l>
<l>dev_display (RoiRectangle)</l>
<c></c>
<l>find_data_matrix (RoiImage, SymbolType, JobPass, ResultCode, CodeXPos, CodeYPos, Contrast, CellDefects, ContrastSNR, PatternDefects)</l>
<l>CodeXPosInMM := CodeXPos * PixelSize</l>
<l>return ()</l>
</body>
<docu id="find_data_matrix_line_scan">
<parameters>
<parameter id="CellDefects">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="CodeXPosInMM">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Contrast">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ContrastSNR">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image"/>
<parameter id="JobPass">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
<value_min>0</value_min>
</parameter>
<parameter id="PatternDefects">
<default_type>real</default_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ResultCode">
<default_type>string</default_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="RoiOffsetInMM">
<default_type>real</default_type>
<default_value>0</default_value>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RoiWidthInMM">
<default_type>real</default_type>
<default_value>300</default_value>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="SymbolType">
<default_type>string</default_type>
<default_value>Data Matrix ECC 200</default_value>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="list_image_files_COPY_1">
<interface>
<ic>
<par name="ImageDirectory" base_type="ctrl" dimension="0"/>
<par name="Extensions" base_type="ctrl" dimension="0"/>
<par name="Options" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure returns all files in a given directory</c>
<c>* with one of the suffixes specified in Extensions.</c>
<c></c>
<c>* Input parameters:</c>
<c>* ImageDirectory: Directory or a tuple of directories with images.</c>
<c>*    If a directory is not found locally, the respective directory</c>
<c>*    is searched under %HALCONIMAGES%/ImageDirectory.</c>
<c>*    See the Installation Guide for further information</c>
<c>*    in case %HALCONIMAGES% is not set.</c>
<c>* Extensions: A string tuple containing the extensions to be found</c>
<c>*    e.g. ['png','tif',jpg'] or others</c>
<c>* If Extensions is set to 'default' or the empty string '',</c>
<c>*    all image suffixes supported by HALCON are used.</c>
<c>* Options: as in the operator list_files, except that the 'files'</c>
<c>*    option is always used. Note that the 'directories' option</c>
<c>*    has no effect but increases runtime, because only files are</c>
<c>*    returned.</c>
<c></c>
<c>* Output parameter:</c>
<c>* ImageFiles: A tuple of all found image file names</c>
<c></c>
<l>if (Extensions == [] or Extensions == '' or Extensions == 'default')</l>
<l>    Extensions := ['ima', 'tif', 'tiff', 'gif', 'bmp', 'jpg', 'jpeg', 'jp2', 'jxr', 'png', 'pcx', 'ras', 'xwd', 'pbm', 'pnm', 'pgm', 'ppm']</l>
<c></c>
<l>endif</l>
<l>ImageFiles := []</l>
<c>* Loop through all given image directories.</c>
<l>for ImageDirectoryIndex := 0 to |ImageDirectory| - 1 by 1</l>
<l>    ImageFilesTmp := []</l>
<l>    CurrentImageDirectory := ImageDirectory[ImageDirectoryIndex]</l>
<l>    if (CurrentImageDirectory == '')</l>
<l>        CurrentImageDirectory := '.'</l>
<l>    endif</l>
<l>    get_system ('image_dir', HalconImages)</l>
<l>    get_system ('operating_system', OS)</l>
<l>    if (OS{0:2} == 'Win')</l>
<l>        HalconImages := split(HalconImages,';')</l>
<l>    else</l>
<l>        HalconImages := split(HalconImages,':')</l>
<l>    endif</l>
<l>    Directories := CurrentImageDirectory</l>
<l>    for Index := 0 to |HalconImages| - 1 by 1</l>
<l>        Directories := [Directories,HalconImages[Index] + '/' + CurrentImageDirectory]</l>
<l>    endfor</l>
<l>    tuple_strlen (Directories, Length)</l>
<l>    tuple_gen_const (|Length|, false, NetworkDrive)</l>
<l>    if (OS{0:2} == 'Win')</l>
<l>        for Index := 0 to |Length| - 1 by 1</l>
<l>            if (strlen(Directories[Index]) &gt; 1)</l>
<l>                tuple_str_first_n (Directories[Index], 1, Substring)</l>
<l>                if (Substring == '//' or Substring == '\\\\')</l>
<l>                    NetworkDrive[Index] := true</l>
<l>                endif</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>    ImageFilesTmp := []</l>
<l>    for Index := 0 to |Directories| - 1 by 1</l>
<l>        file_exists (Directories[Index], FileExists)</l>
<l>        if (FileExists)</l>
<l>            list_files (Directories[Index], ['files',Options], AllFiles)</l>
<l>            ImageFilesTmp := []</l>
<l>            for i := 0 to |Extensions| - 1 by 1</l>
<l>                tuple_regexp_select (AllFiles, ['.*' + Extensions[i] + '$','ignore_case'], Selection)</l>
<l>                ImageFilesTmp := [ImageFilesTmp,Selection]</l>
<l>            endfor</l>
<l>            tuple_regexp_replace (ImageFilesTmp, ['\\\\', 'replace_all'], '/', ImageFilesTmp)</l>
<l>            if (NetworkDrive[Index])</l>
<l>                tuple_regexp_replace (ImageFilesTmp, ['//', 'replace_all'], '/', ImageFilesTmp)</l>
<l>                ImageFilesTmp := '/' + ImageFilesTmp</l>
<l>            else</l>
<l>                tuple_regexp_replace (ImageFilesTmp, ['//', 'replace_all'], '/', ImageFilesTmp)</l>
<l>            endif</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Concatenate the output image paths.</c>
<l>    ImageFiles := [ImageFiles,ImageFilesTmp]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="list_image_files_COPY_1">
<abstract lang="en_US">This procedure returns all files in a given directory ImageDirectory with one of the suffixes specified in Extensions.

It is possible to use a tuple with multiple directories as input ImageDirectory. If a directory is not found locally, the respective directory is searched under %HALCONIMAGES%/ImageDirectory. See the `Installation Guide` for further information in case %HALCONIMAGES% is not set.

If Extensions is set to *'default'* or the empty string *''*, all image suffixes supported by HALCON are used.

The parameter Options is used as in the operator &lt;op:list_files&gt; (see &lt;op:list_files&gt; for details), except that the *'files'* option is always used. Note that the *'directories'* option has no effect but increases runtime, because only files are returned.</abstract>
<alternatives>
<item>list_files</item>
</alternatives>
<chapters lang="de_DE">
<item>Datei</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<chapters lang="ja_JP">
<item>ファイル</item>
<item>その他</item>
</chapters>
<example lang="en_US">list_image_files ('.',[] ,[] , ImageFiles)
for Index := 1 to |ImageFiles|  by 1
    read_image (Image,ImageFiles[Index-1])
*     do something
endfor</example>
<keywords lang="de_DE">
<item>Bilddateien auflisten</item>
</keywords>
<keywords lang="en_US">
<item>list image files</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>list_files</item>
</predecessor>
<see_also>
<item>list_files</item>
</see_also>
<short>Get all image files under the given path</short>
<short lang="de_DE">Get all image files under the given path</short>
<short lang="en_US">Get all image files under the given path</short>
<successor>
<item>read_image</item>
</successor>
<parameters>
<parameter id="Extensions">
<default_type>string</default_type>
<default_value>'default'</default_value>
<description lang="en_US">A string tuple containing the extensions to be found e.g. ['png','tif',jpg'] or others</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'ima'</item>
<item>'bmp'</item>
<item>'jpg'</item>
<item>'png'</item>
<item>'tiff'</item>
<item>'tif'</item>
<item>'gif'</item>
<item>'jpeg'</item>
<item>'pcx'</item>
<item>'pgm'</item>
<item>'ppm'</item>
<item>'pbm'</item>
<item>'xwd'</item>
<item>'pnm'</item>
</values>
</parameter>
<parameter id="ImageDirectory">
<default_type>string</default_type>
<description lang="en_US">The image directory</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">A tuple of all found image file names</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.read</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Options">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Processing options</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'recursive'</item>
<item>'follow_links'</item>
<item>'max_depth 5'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="clear_and_make_image_dir">
<interface>
<ic>
<par name="DirName" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>try</l>
<l>make_dir(DirName)</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c></c>
<l>list_files (DirName, ['files','recursive'], ExampleFiles)</l>
<l>for Index := |ExampleFiles| to 1 by -1</l>
<l> delete_file (ExampleFiles[Index - 1])</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="clear_and_make_image_dir">
<parameters>
<parameter id="DirName">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="add_image_line_scan_buffer">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="LineScanImages" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="BufferFull" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>BufferFull := 0</l>
<l>global object GlobalImagesToTile</l>
<l>global tuple GlobalNumberSubLineScanImages</l>
<c></c>
<l>Number := 0</l>
<l>try</l>
<l> count_obj(GlobalImagesToTile,Number)</l>
<l>catch(Exception)</l>
<c> *hier noch kein Bild aufgenommen. Erzeuge leeres Objekt   </c>
<l> gen_empty_obj (GlobalImagesToTile)</l>
<l>endtry</l>
<l>try</l>
<c>*FIFO prinzip first in frist out</c>
<l>if(Number == GlobalNumberSubLineScanImages)</l>
<c>  *Ältesten Bildblock entfernen  </c>
<l>  remove_obj(GlobalImagesToTile,GlobalImagesToTile,1)</l>
<l>endif</l>
<c>*Neuen Bildblock am Ende anhängen</c>
<l>concat_obj (GlobalImagesToTile, InputImage, GlobalImagesToTile)</l>
<c>*Es müssen mindestens GlobalNumberSubLineScanImages Bilder aufgenommen werden die dann zu einem Gesamtbild zusammengesetzt werden</c>
<l>if(Number&lt;(GlobalNumberSubLineScanImages-1))</l>
<c>    *Buffer ist noch nicht voll</c>
<l>    return()</l>
<l>endif</l>
<c>*Einzelbilder vertikal zusammensetzen</c>
<l>tile_images (GlobalImagesToTile, LineScanImages, 1, 'vertical')</l>
<l>catch(Exception)</l>
<l>    dev_get_exception_data(Exception, 'error_message',ErrorMsg)</l>
<l>    throw ('Error Start int_calibrate_camera before start evaluate_calibration_images ' + ErrorMsg)</l>
<l>    return()</l>
<l>endtry</l>
<l>BufferFull := 1</l>
<l>return()</l>
</body>
<docu id="add_image_line_scan_buffer">
<parameters>
<parameter id="BufferFull">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
<parameter id="InputImage"/>
<parameter id="LineScanImages"/>
</parameters>
</docu>
</procedure>
<procedure name="clear_buffer_line_scan">
<interface/>
<body>
<l>global object GlobalImagesToTile</l>
<l>try</l>
<l>    Number:=0</l>
<l>    count_obj(GlobalImagesToTile,Number)</l>
<l>    for Index := 1 to Number by 1</l>
<l>       remove_obj(GlobalImagesToTile,GlobalImagesToTile,1)</l>
<l>    endfor</l>
<l>    catch(Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="clear_buffer_line_scan">
<parameters/>
</docu>
</procedure>
</hdevelop>
